<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>/</id><title>177博客</title><updated>2020-01-15T10:02:27.596665+08:06</updated><author><name>177</name><email>0@177.im</email></author><link href="/" rel="alternate"/><generator uri="http://lkiesow.github.io/python-feedgen" version="0.8.0">python-feedgen</generator><logo>${static_prefix}favicon.ico</logo><subtitle>天青色等烟雨</subtitle><entry><id>/archives/java-interview-springboot/</id><title>Java面试题-SpringBoot</title><updated>2020-01-15T10:02:27.596888+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1、什么是 Spring Boot？&lt;/h2&gt;
&lt;p&gt;Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式处理方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。&lt;/p&gt;
&lt;h2&gt;2、为什么要用 Spring Boot？&lt;/h2&gt;
&lt;p&gt;Spring Boot 优点非常多，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- 独立运行

- 简化配置

- 自动配置

- 无代码生成和XML配置

- 应用监控

- 上手容易…..

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3、Spring Boot 的核心配置文件有哪几个？它们的区别是什么？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。

- application 配置文件这个容易了解，主要用于 Spring Boot 项目的自动化配置。

- bootstrap 配置文件有以下几个应用场景。

- 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中增加连接到配置中心的配置属性来加载外部配置中心的配置信息；

- 少量固定的不能被覆盖的属性；

- 少量加密/解密的场景；

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;4、Spring Boot 的配置文件有哪几种格式？它们有什么区别？&lt;/h2&gt;
&lt;p&gt;.properties 和 .yml，它们的区别主要是书写格式不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1).properties

2).yml

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，.yml 格式不支持@PropertySource注解导入配置。&lt;/p&gt;
&lt;h2&gt;5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？&lt;/h2&gt;
&lt;p&gt;启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：&lt;/p&gt;
&lt;p&gt;@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。&lt;/p&gt;
&lt;p&gt;@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。&lt;/p&gt;
&lt;p&gt;@ComponentScan：Spring组件扫描。&lt;/p&gt;
&lt;h2&gt;6、开启 Spring Boot 特性有哪几种方式？&lt;/h2&gt;
&lt;p&gt;1）继承spring-boot-starter-parent项目&lt;/p&gt;
&lt;p&gt;2）导入spring-boot-dependencies项目依赖&lt;/p&gt;
&lt;h2&gt;7、Spring Boot 需要独立的容器运行吗？&lt;/h2&gt;
&lt;p&gt;可以不需要，内置了 Tomcat/ Jetty 等容器。&lt;/p&gt;
&lt;h2&gt;8、运行 Spring Boot 有哪几种方式？&lt;/h2&gt;
&lt;p&gt;1）打包用命令或者者放到容器中运行&lt;/p&gt;
&lt;p&gt;2）用 Maven/ Gradle 插件运行&lt;/p&gt;
&lt;p&gt;3）直接执行 main 方法运行&lt;/p&gt;
&lt;h2&gt;9.springboot常用的starter有哪些?&lt;/h2&gt;
&lt;p&gt;spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-jpa 数据库支持&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-redis redis数据库支持&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-solr solr支持&lt;/p&gt;
&lt;p&gt;mybatis-spring-boot-starter 第三方的mybatis集成starter&lt;/p&gt;
&lt;h2&gt;10、Spring Boot 自动配置原理是什么？&lt;/h2&gt;
&lt;p&gt;注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下能否有这个类去自动配置。&lt;/p&gt;
&lt;h2&gt;11、Spring Boot 的目录结构是怎么的？&lt;/h2&gt;
&lt;p&gt;这个目录结构是主流及推荐的做法，而在主入口类上加上 @SpringBootApplication 注解来开启 Spring Boot 的各项能力，如自动配置、组件扫描等。&lt;/p&gt;
&lt;h2&gt;12、你如何了解 Spring Boot 中的 Starters？&lt;/h2&gt;
&lt;p&gt;Starters可以了解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其余技术，而不需要四处找示例代码和依赖包。&lt;/p&gt;
&lt;p&gt;如你想使用 Spring JPA 访问数据库，只需加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。&lt;/p&gt;
&lt;p&gt;Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。&lt;/p&gt;
&lt;h2&gt;13、如何在 Spring Boot 启动的时候运行少量特定的代码？&lt;/h2&gt;
&lt;p&gt;可以实现接口 ApplicationRunner 或者者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法&lt;/p&gt;
&lt;h2&gt;14、Spring Boot 有哪几种读取配置的方式？&lt;/h2&gt;
&lt;p&gt;Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量&lt;/p&gt;
&lt;h2&gt;15、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？&lt;/h2&gt;
&lt;p&gt;Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，假如你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架&lt;/p&gt;
&lt;h2&gt;16、SpringBoot 实现热部署有哪几种方式？&lt;/h2&gt;
&lt;p&gt;主要有两种方式：&lt;/p&gt;
&lt;p&gt;Spring Loaded&lt;/p&gt;
&lt;p&gt;Spring-boot-devtools&lt;/p&gt;
&lt;h2&gt;17、你如何了解 Spring Boot 配置加载顺序？&lt;/h2&gt;
&lt;p&gt;在 Spring Boot 里面，可以使用以下几种方式来加载配置。&lt;/p&gt;
&lt;p&gt;1）properties文件；&lt;/p&gt;
&lt;p&gt;2）YAML文件；&lt;/p&gt;
&lt;p&gt;3）系统环境变量；&lt;/p&gt;
&lt;p&gt;4）命令行参数；&lt;/p&gt;
&lt;p&gt;等等……&lt;/p&gt;
&lt;h2&gt;18、Spring Boot 如何定义多套不同环境配置？&lt;/h2&gt;
&lt;p&gt;提供多套配置文件，如：&lt;/p&gt;
&lt;p&gt;运行时指定具体的配置文件&lt;/p&gt;
&lt;h2&gt;19、Spring Boot 可以兼容老 Spring 项目吗，如何做？&lt;/h2&gt;
&lt;p&gt;可以兼容，使用@ImportResource注解导入老 Spring 项目配置文件。&lt;/p&gt;
&lt;h2&gt;20、保护 Spring Boot 应用有哪些方法？&lt;/h2&gt;
&lt;p&gt;在生产中使用HTTPS&lt;/p&gt;
&lt;p&gt;使用Snyk检查你的依赖关系&lt;/p&gt;
&lt;p&gt;更新到最新版本&lt;/p&gt;
&lt;p&gt;启用CSRF保护&lt;/p&gt;
&lt;p&gt;使用内容安全策略防止XSS攻击…&lt;/p&gt;
&lt;h2&gt;21、Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？&lt;/h2&gt;
&lt;p&gt;配置变更&lt;/p&gt;
&lt;p&gt;JDK 版本更新&lt;/p&gt;
&lt;p&gt;第三方类库更新&lt;/p&gt;
&lt;p&gt;响应式 Spring 编程支持&lt;/p&gt;
&lt;p&gt;HTTP/2 支持&lt;/p&gt;
&lt;p&gt;配置属性绑定&lt;/p&gt;
&lt;p&gt;更多改进与增强…&lt;/p&gt;
&lt;h2&gt;22.什么是Spring Profiles？&lt;/h2&gt;
&lt;p&gt;Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。&lt;/p&gt;
&lt;p&gt;因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。&lt;/p&gt;
&lt;p&gt;假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单。&lt;/p&gt;
&lt;h2&gt;23.什么是Spring Batch？&lt;/h2&gt;
&lt;p&gt;Spring Boot Batch提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。&lt;/p&gt;
&lt;p&gt;它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。&lt;/p&gt;
&lt;p&gt;简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。&lt;/p&gt;
&lt;h2&gt;24.什么是FreeMarker模板？&lt;/h2&gt;
&lt;p&gt;FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构进行动态网页生成。使用Freemarker的主要优点是表示层和业务层的完全分离。&lt;/p&gt;
&lt;p&gt;程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后使用freemarker可以将这些结合起来，给出最终的输出页面。&lt;/p&gt;
&lt;h2&gt;25.什么是JavaConfig？&lt;/h2&gt;
&lt;p&gt;Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。&lt;/p&gt;
&lt;p&gt;使用JavaConfig的优点在于：&lt;/p&gt;
&lt;p&gt;面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。&lt;/p&gt;
&lt;p&gt;减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。&lt;/p&gt;
&lt;p&gt;JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。&lt;/p&gt;
&lt;p&gt;从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。&lt;/p&gt;
&lt;p&gt;类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找&lt;/p&gt;
&lt;h2&gt;26.启动类注解：&lt;/h2&gt;
&lt;p&gt;@SpringBootConfiguration:Spring Boot的配置类; 标注在某个类上，表示这是一个Spring Boot的配置类; @Configuration:配置类上来标注这个注解;&lt;/p&gt;
&lt;p&gt;配置类 —– 配置文件;配置类也是容器中的一个组件;@Component@EnableAutoConfiguration:开启自动配置功能;&lt;/p&gt;
&lt;p&gt;以前我们需要配置的东西，Spring Boot帮我们自动配置;@EnableAutoConfiguration告诉SpringBoot开启自动配置功能;这样自动配置才能生效;&lt;/p&gt;
&lt;p&gt;Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就失效，帮我们进行自动配置工作&lt;/p&gt;
&lt;h2&gt;27.配置文件的加载顺序?&lt;/h2&gt;
&lt;p&gt;由jar包外向jar包内进行寻找;&lt;/p&gt;
&lt;p&gt;优先加载带profile&lt;/p&gt;
&lt;p&gt;jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件&lt;/p&gt;
&lt;p&gt;jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件&lt;/p&gt;
&lt;p&gt;再来加载不带profile&lt;/p&gt;
&lt;p&gt;jar包外部的application.properties或application.yml(不带spring.profile)配置文件&lt;/p&gt;
&lt;p&gt;jar包内部的application.properties或application.yml(不带spring.profile)配置文件&lt;/p&gt;
&lt;h2&gt;28.自动配置原理?&lt;/h2&gt;
&lt;p&gt;1)、SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration&lt;/p&gt;
&lt;p&gt;2)、@EnableAutoConfiguration 作用:将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中;每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中;用他们来做自动配置;&lt;/p&gt;
&lt;p&gt;3)、每一个自动配置类进行自动配置功能;根据当前不同的条件判断，决定这个配置类是否生效?&lt;/p&gt;
&lt;p&gt;一但这个配置类生效;这个配置类就会给容器中添加各种组件;这些组件的属性是从对应的properties类中获取 的，这些类里面的每一个属性又是和配置文件绑定的;&lt;/p&gt;
&lt;p&gt;4)、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘;配置文件能配置什么就可以参照某个功 能对应的这个属性类怎么用好自动配置，精髓:
– 1)、SpringBoot启动会加载大量的自动配置类
– 2)、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类;
– 3)、我们再来看这个自动配置类中到底配置了哪些组件;(只要我们要用的组件有，我们就不需要再来配置了)
– 4)、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这 些属性的值;&lt;/p&gt;
</content><link href="/archives/java-interview-springboot/" rel="alternate"/><published>2020-01-09T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-springcloud/</id><title>Java面试题-SpringCloud</title><updated>2020-01-15T10:02:27.596871+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. 什么是 spring cloud？&lt;/h2&gt;
&lt;p&gt;spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。&lt;/p&gt;
&lt;h2&gt;2. spring cloud 断路器的作用是什么？&lt;/h2&gt;
&lt;p&gt;在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。&lt;/p&gt;
&lt;h2&gt;3. spring cloud 的核心组件有哪些？&lt;/h2&gt;
&lt;p&gt;Eureka：服务注册于发现。&lt;/p&gt;
&lt;p&gt;Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。&lt;/p&gt;
&lt;p&gt;Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。&lt;/p&gt;
&lt;p&gt;Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。&lt;/p&gt;
&lt;p&gt;Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。&lt;/p&gt;
&lt;h2&gt;4.SpringCloud和Dubbo&lt;/h2&gt;
&lt;p&gt;SpringCloud和Dubbo都是现在主流的微服务架构&lt;/p&gt;
&lt;p&gt;SpringCloud是Apache旗下的Spring体系下的微服务解决方案&lt;/p&gt;
&lt;p&gt;Dubbo是阿里系的分布式服务治理框架&lt;/p&gt;
&lt;p&gt;从技术维度上,其实SpringCloud远远的超过Dubbo,Dubbo本身只是实现了服务治理,而SpringCloud现在以及有21个子项目以后还会更多&lt;/p&gt;
&lt;p&gt;所以其实很多人都会说Dubbo和SpringCloud是不公平的&lt;/p&gt;
&lt;p&gt;但是由于RPC以及注册中心元数据等原因,在技术选型的时候我们只能二者选其一,所以我们常常为用他俩来对比&lt;/p&gt;
&lt;p&gt;服务的调用方式Dubbo使用的是RPC远程调用,而SpringCloud使用的是 Rest API,其实更符合微服务官方的定义&lt;/p&gt;
&lt;p&gt;服务的注册中心来看,Dubbo使用了第三方的ZooKeeper作为其底层的注册中心,实现服务的注册和发现,SpringCloud使用Spring Cloud Netflix Eureka实现注册中心,当然SpringCloud也可以使用ZooKeeper实现,但一般我们不会这样做&lt;/p&gt;
&lt;p&gt;服务网关,Dubbo并没有本身的实现,只能通过其他第三方技术的整合,而SpringCloud有Zuul路由网关,作为路由服务器,进行消费者的请求分发,SpringCloud还支持断路器,与git完美集成分布式配置文件支持版本控制,事务总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素&lt;/p&gt;
&lt;h3&gt;从技术选型上讲&lt;/h3&gt;
&lt;p&gt;目前国内的分布式系统选型主要还是Dubbo毕竟国产,而且国内工程师的技术熟练程度高,并且Dubbo在其他维度上的缺陷可以由其他第三方框架进行集成进行弥补&lt;/p&gt;
&lt;p&gt;而SpringCloud目前是国外比较流行,当然我觉得国内的市场也会慢慢的偏向SpringCloud,就连刘军作为Dubbo重启的负责人也发表过观点,Dubbo的发展方向是积极适应SpringCloud生态,并不是起冲突&lt;/p&gt;
&lt;h3&gt;Rest和RPC对比&lt;/h3&gt;
&lt;p&gt;其实如果仔细阅读过微服务提出者马丁福勒的论文的话可以发现其定义的服务间通信机制就是Http Rest&lt;/p&gt;
&lt;p&gt;RPC最主要的缺陷就是服务提供方和调用方式之间依赖太强,我们需要为每一个微服务进行接口的定义,并通过持续继承发布,需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突&lt;/p&gt;
&lt;p&gt;而REST是轻量级的接口,服务的提供和调用不存在代码之间的耦合,只是通过一个约定进行规范,但也有可能出现文档和接口不一致而导致的服务集成问题,但可以通过swagger工具整合,是代码和文档一体化解决,所以REST在分布式环境下比RPC更加灵活&lt;/p&gt;
&lt;p&gt;这也是为什么当当网的DubboX在对Dubbo的增强中增加了对REST的支持的原因&lt;/p&gt;
&lt;h3&gt;文档质量和社区活跃度&lt;/h3&gt;
&lt;p&gt;SpringCloud社区活跃度远高于Dubbo,毕竟由于梁飞团队的原因导致Dubbo停止更新迭代五年,而中小型公司无法承担技术开发的成本导致Dubbo社区严重低落,而SpringCloud异军突起,迅速占领了微服务的市场,背靠Spring混的风生水起&lt;/p&gt;
&lt;p&gt;Dubbo经过多年的积累文档相当成熟,对于微服务的架构体系各个公司也有稳定的现状&lt;/p&gt;
&lt;h2&gt;5.SpringBoot和SpringCloud&lt;/h2&gt;
&lt;p&gt;SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务&lt;/p&gt;
&lt;p&gt;而SpringCloud专注于解决各个微服务之间的协调与配置,服务之间的通信,熔断,负载均衡等&lt;/p&gt;
&lt;p&gt;技术维度并相同,并且SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;p&gt;SpringBoot专注于快速方便的开发单个个体的微服务&lt;/p&gt;
&lt;p&gt;SpringCloud是关注全局的微服务协调整理治理框架,整合并管理各个微服务,为各个微服务之间提供,配置管理,服务发现,断路器,路由,事件总线等集成服务&lt;/p&gt;
&lt;p&gt;SpringBoot不依赖于SpringCloud,SpringCloud依赖于SpringBoot,属于依赖关系&lt;/p&gt;
&lt;p&gt;SpringBoot专注于快速,方便的开发单个的微服务个体,SpringCloud关注全局的服务治理框架&lt;/p&gt;
&lt;h2&gt;6.Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别&lt;/h2&gt;
&lt;p&gt;1.ZooKeeper保证的是CP,Eureka保证的是AP&lt;/p&gt;
&lt;p&gt;ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的&lt;/p&gt;
&lt;p&gt;Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的&lt;/p&gt;
&lt;p&gt;自我保护机制会导致&lt;/p&gt;
&lt;p&gt;Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务&lt;/p&gt;
&lt;p&gt;Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)&lt;/p&gt;
&lt;p&gt;当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)&lt;/p&gt;
&lt;p&gt;Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪&lt;/p&gt;
&lt;p&gt;2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等&lt;/p&gt;
&lt;p&gt;3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题&lt;/p&gt;
&lt;p&gt;4.Eureka本质上是一个工程,而ZooKeeper只是一个进程&lt;/p&gt;
&lt;h2&gt;7.微服务之间是如何独立通讯的&lt;/h2&gt;
&lt;p&gt;1.远程过程调用（Remote Procedure Invocation）：&lt;/p&gt;
&lt;p&gt;也就是我们常说的服务的注册与发现&lt;/p&gt;
&lt;p&gt;直接通过远程过程调用来访问别的service。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;简单，常见,因为没有中间件代理，系统更简单&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;只支持请求/响应的模式，不支持别的，比如通知、请求/异步响应、发布/订阅、发布/异步响应&lt;/p&gt;
&lt;p&gt;降低了可用性，因为客户端和服务端在请求过程中必须都是可用的&lt;/p&gt;
&lt;p&gt;2.消息：&lt;/p&gt;
&lt;p&gt;使用异步消息来做服务间通信。服务间通过消息管道来交换消息，从而通信。&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;p&gt;把客户端和服务端解耦，更松耦合&lt;/p&gt;
&lt;p&gt;提高可用性，因为消息中间件缓存了消息，直到消费者可以消费&lt;/p&gt;
&lt;p&gt;支持很多通信机制比如通知、请求/异步响应、发布/订阅、发布/异步响应&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;p&gt;消息中间件有额外的复杂&lt;/p&gt;
&lt;h2&gt;8.什么是服务熔断?什么是服务降级&lt;/h2&gt;
&lt;p&gt;在复杂的分布式系统中,微服务之间的相互调用,有可能出现各种各样的原因导致服务的阻塞,在高并发场景下,服务的阻塞意味着线程的阻塞,导致当前线程不可用,服务器的线程全部阻塞,导致服务器崩溃,由于服务之间的调用关系是同步的,会对整个微服务系统造成服务雪崩&lt;/p&gt;
&lt;p&gt;为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。&lt;/p&gt;
&lt;p&gt;所谓的服务熔断指的是某个服务故障或异常一起类似显示世界中的“保险丝”当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。&lt;/p&gt;
&lt;p&gt;服务熔断就是相当于我们电闸的保险丝,一旦发生服务雪崩的,就会熔断整个服务,通过维护一个自己的线程池,当线程达到阈值的时候就启动服务降级,如果其他请求继续访问就直接返回fallback的默认值&lt;/p&gt;
&lt;h2&gt;9.微服务的优缺点分别是什么?说下你在项目开发中碰到的坑&lt;/h2&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;每一个服务足够内聚,代码容易理解&lt;/p&gt;
&lt;p&gt;开发效率提高,一个服务只做一件事&lt;/p&gt;
&lt;p&gt;微服务能够被小团队单独开发&lt;/p&gt;
&lt;p&gt;微服务是松耦合的,是有功能意义的服务&lt;/p&gt;
&lt;p&gt;可以用不同的语言开发,面向接口编程&lt;/p&gt;
&lt;p&gt;易于与第三方集成&lt;/p&gt;
&lt;p&gt;微服务只是业务逻辑的代码,不会和HTML,CSS或者其他界面组合&lt;/p&gt;
&lt;p&gt;开发中,两种开发模式:前后端分离,全栈工程师&lt;/p&gt;
&lt;p&gt;可以灵活搭配,连接公共库/连接独立库&lt;/p&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;分布式系统的负责性&lt;/p&gt;
&lt;p&gt;多服务运维难度,随着服务的增加,运维的压力也在增大&lt;/p&gt;
&lt;p&gt;系统部署依赖&lt;/p&gt;
&lt;p&gt;服务间通信成本&lt;/p&gt;
&lt;p&gt;数据一致性&lt;/p&gt;
&lt;p&gt;系统集成测试&lt;/p&gt;
&lt;p&gt;性能监控&lt;/p&gt;
&lt;h2&gt;10.Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别&lt;/h2&gt;
&lt;p&gt;1.ZooKeeper保证的是CP,Eureka保证的是AP&lt;/p&gt;
&lt;p&gt;ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的&lt;/p&gt;
&lt;p&gt;Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的&lt;/p&gt;
&lt;p&gt;自我保护机制会导致&lt;/p&gt;
&lt;p&gt;Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务&lt;/p&gt;
&lt;p&gt;Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)&lt;/p&gt;
&lt;p&gt;当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)&lt;/p&gt;
&lt;p&gt;Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪&lt;/p&gt;
&lt;p&gt;2.ZooKeeper有Leader和Follower角色,Eureka各个节点平等&lt;/p&gt;
&lt;p&gt;3.ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题&lt;/p&gt;
&lt;p&gt;4.Eureka本质上是一个工程,而ZooKeeper只是一个进程&lt;/p&gt;
</content><link href="/archives/java-interview-springcloud/" rel="alternate"/><published>2020-01-10T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-springmvc/</id><title>Java面试题-SpringMVC</title><updated>2020-01-15T10:02:27.596855+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. 什么是spring?&lt;/h2&gt;
&lt;p&gt;Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。&lt;/p&gt;
&lt;h2&gt;2. 使用Spring框架的好处是什么？&lt;/h2&gt;
&lt;p&gt;轻量：Spring 是轻量的，基本的版本大约2MB。&lt;/p&gt;
&lt;p&gt;控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。&lt;/p&gt;
&lt;p&gt;面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。&lt;/p&gt;
&lt;p&gt;容器：Spring 包含并管理应用中对象的生命周期和配置。&lt;/p&gt;
&lt;p&gt;MVC框架：Spring 的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。&lt;/p&gt;
&lt;p&gt;事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。&lt;/p&gt;
&lt;p&gt;异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常&lt;/p&gt;
&lt;h2&gt;3. 解释一下什么是 AOP？&lt;/h2&gt;
&lt;p&gt;aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。&lt;/p&gt;
&lt;p&gt;简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。&lt;/p&gt;
&lt;h2&gt;4. 解释一下什么是IOC？&lt;/h2&gt;
&lt;p&gt;ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。&lt;/p&gt;
&lt;p&gt;简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。&lt;/p&gt;
&lt;h2&gt;5. spring 有哪些主要模块？&lt;/h2&gt;
&lt;p&gt;spring core：框架的最基础部分，提供 ioc 和依赖注入特性。&lt;/p&gt;
&lt;p&gt;spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。&lt;/p&gt;
&lt;p&gt;spring dao：Data Access Object 提供了JDBC的抽象层。&lt;/p&gt;
&lt;p&gt;spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。&lt;/p&gt;
&lt;p&gt;spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。&lt;/p&gt;
&lt;p&gt;spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。&lt;/p&gt;
&lt;h2&gt;6. spring 常用的注入方式有哪些？&lt;/h2&gt;
&lt;p&gt;setter 属性注入&lt;/p&gt;
&lt;p&gt;构造方法注入&lt;/p&gt;
&lt;p&gt;注解方式注入&lt;/p&gt;
&lt;h2&gt;7. spring 中的 bean 是线程安全的吗？&lt;/h2&gt;
&lt;p&gt;spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。&lt;/p&gt;
&lt;p&gt;实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。&lt;/p&gt;
&lt;p&gt;有状态就是有数据存储功能。&lt;/p&gt;
&lt;p&gt;无状态就是不会保存数据。&lt;/p&gt;
&lt;h2&gt;8. spring 支持几种 bean 的作用域？&lt;/h2&gt;
&lt;p&gt;spring 支持 5 种作用域，如下：&lt;/p&gt;
&lt;p&gt;singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；&lt;/p&gt;
&lt;p&gt;prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；&lt;/p&gt;
&lt;p&gt;Web 环境下的作用域：&lt;/p&gt;
&lt;p&gt;request：每次 http 请求都会创建一个 bean；&lt;/p&gt;
&lt;p&gt;session：同一个 http session 共享一个 bean 实例；&lt;/p&gt;
&lt;p&gt;global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。&lt;/p&gt;
&lt;p&gt;注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。&lt;/p&gt;
&lt;h2&gt;9. spring 自动装配 bean 有哪些方式？&lt;/h2&gt;
&lt;p&gt;no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。&lt;/p&gt;
&lt;p&gt;byName：它根据 bean 的名称注入对象依赖项。&lt;/p&gt;
&lt;p&gt;byType：它根据类型注入对象依赖项。&lt;/p&gt;
&lt;p&gt;构造函数：通过构造函数来注入依赖项，需要设置大量的参数。&lt;/p&gt;
&lt;p&gt;autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。&lt;/p&gt;
&lt;h2&gt;10. spring 事务实现方式有哪些？&lt;/h2&gt;
&lt;p&gt;声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。&lt;/p&gt;
&lt;p&gt;编码方式：提供编码的形式管理和维护事务。&lt;/p&gt;
&lt;h2&gt;11. 说一下 spring 的事务隔离？&lt;/h2&gt;
&lt;p&gt;spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：&lt;/p&gt;
&lt;p&gt;ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；&lt;/p&gt;
&lt;p&gt;ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；&lt;/p&gt;
&lt;p&gt;ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；&lt;/p&gt;
&lt;p&gt;ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；&lt;/p&gt;
&lt;p&gt;ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。&lt;/p&gt;
&lt;p&gt;脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。&lt;/p&gt;
&lt;p&gt;不可重复读 ：是指在一个事务内，多次读同一数据。&lt;/p&gt;
&lt;p&gt;幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。&lt;/p&gt;
&lt;h2&gt;12. 什么是Spring的MVC框架？&lt;/h2&gt;
&lt;p&gt;Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。&lt;/p&gt;
&lt;h2&gt;13. 说一下 spring mvc 运行流程？&lt;/h2&gt;
&lt;p&gt;spring mvc 先将请求发送给 DispatcherServlet。&lt;/p&gt;
&lt;p&gt;DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。&lt;/p&gt;
&lt;p&gt;DispatcherServlet 再把请求提交到对应的 Controller。&lt;/p&gt;
&lt;p&gt;Controller 进行业务逻辑处理后，会返回一个ModelAndView。&lt;/p&gt;
&lt;p&gt;Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。&lt;/p&gt;
&lt;p&gt;视图对象负责渲染返回给客户端。&lt;/p&gt;
&lt;h2&gt;14. spring mvc 有哪些组件？&lt;/h2&gt;
&lt;p&gt;前置控制器 DispatcherServlet。&lt;/p&gt;
&lt;p&gt;映射控制器 HandlerMapping。&lt;/p&gt;
&lt;p&gt;处理器 Controller。&lt;/p&gt;
&lt;p&gt;模型和视图 ModelAndView。&lt;/p&gt;
&lt;p&gt;视图解析器 ViewResolver。&lt;/p&gt;
&lt;h2&gt;15. @RequestMapping 的作用是什么？&lt;/h2&gt;
&lt;p&gt;将 http 请求映射到相应的类/方法上。&lt;/p&gt;
&lt;h2&gt;16. @Autowired 和@Resource 的区别？&lt;/h2&gt;
&lt;p&gt;1、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配&lt;/p&gt;
&lt;p&gt;2、@Autowired是Spring的注解，@Resource是J2EE的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了&lt;/p&gt;
&lt;p&gt;Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。&lt;/p&gt;
</content><link href="/archives/java-interview-springmvc/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-redis/</id><title>Java面试题-Redis</title><updated>2020-01-15T10:02:27.596838+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. Redis 是什么？都有哪些使用场景？&lt;/h2&gt;
&lt;p&gt;我们先来理解经典的CAP理论：&lt;/p&gt;
&lt;p&gt;一致性：是指从数据层面来看的一致性。&lt;/p&gt;
&lt;p&gt;可用性：是指从系统层面的可用性。&lt;/p&gt;
&lt;p&gt;容错性：是指从网络层面的的容错性。&lt;/p&gt;
&lt;p&gt;数据库逐渐从关系数据库向不同领域不同层次分化。随着读多写少场景的出现，导致需要读取数据的时间变慢，为了提升性能，出现了数据库缓存技术，对数据库的读取进行分离。web2.0时代，网民的生产力大增，存储总量也在增加，目前还是读多写少模式，原有的缓存技术显然不能满足写的压力，所以，出现了分库分表，实现读写分离。其中比较常用的一种缓存技术是用Redis做缓存。&lt;/p&gt;
&lt;p&gt;Redis是什么？&lt;/p&gt;
&lt;p&gt;Redis是一个基于内存且支持持久化的key-value的NoSQL数据库，其中每个key和value都是使用对象表示的，具有以以下特征：多样数据类型、持久化、主从同步。&lt;/p&gt;
&lt;p&gt;和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。&lt;/p&gt;
&lt;p&gt;在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的使用RDB快照的方式，把更新的数据写入磁盘或者使用类似MySQL的AOF日志方式把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。&lt;/p&gt;
&lt;p&gt;Redis3.0版本允许单点故障，它没有中心节点，各个节点地位一样，扩展性很好，节点间的采用二进制通信，节点与客户端采用ascII协议通信。&lt;/p&gt;
&lt;p&gt;综上所述，Redis可用于缓存、数据库、消息中间件。&lt;/p&gt;
&lt;p&gt;Redis 使用场景：&lt;/p&gt;
&lt;p&gt;记录帖子点赞数、点击数、评论数；&lt;/p&gt;
&lt;p&gt;缓存近期热帖；&lt;/p&gt;
&lt;p&gt;缓存文章详情信息；&lt;/p&gt;
&lt;p&gt;记录用户会话信息。&lt;/p&gt;
&lt;h2&gt;2. Redis 有哪些功能？&lt;/h2&gt;
&lt;p&gt;数据缓存功能&lt;/p&gt;
&lt;p&gt;分布式锁的功能&lt;/p&gt;
&lt;p&gt;支持数据持久化&lt;/p&gt;
&lt;p&gt;支持事务&lt;/p&gt;
&lt;p&gt;支持消息队列&lt;/p&gt;
&lt;h2&gt;3. Redis 和 memcache 有什么区别？&lt;/h2&gt;
&lt;p&gt;存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。&lt;/p&gt;
&lt;p&gt;数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。&lt;/p&gt;
&lt;p&gt;使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。&lt;/p&gt;
&lt;p&gt;value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。&lt;/p&gt;
&lt;h2&gt;4. Redis 为什么是单线程的？&lt;/h2&gt;
&lt;p&gt;因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。&lt;/p&gt;
&lt;p&gt;关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。&lt;/p&gt;
&lt;p&gt;而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。&lt;/p&gt;
&lt;h2&gt;5. 什么是缓存穿透？怎么解决？&lt;/h2&gt;
&lt;p&gt;缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。&lt;/p&gt;
&lt;p&gt;解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。&lt;/p&gt;
&lt;h2&gt;6. Redis 支持的数据类型有哪些？&lt;/h2&gt;
&lt;p&gt;Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。&lt;/p&gt;
&lt;h2&gt;7. Redis 支持的 Java 客户端都有哪些？&lt;/h2&gt;
&lt;p&gt;支持的 Java 客户端有 Redisson、jedis、lettuce 等。&lt;/p&gt;
&lt;h2&gt;8. jedis 和 Redisson 有哪些区别？&lt;/h2&gt;
&lt;p&gt;jedis：提供了比较全面的 Redis 命令的支持。&lt;/p&gt;
&lt;p&gt;Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。&lt;/p&gt;
&lt;h2&gt;9. 怎么保证缓存和数据库数据的一致性？&lt;/h2&gt;
&lt;p&gt;合理设置缓存的过期时间。&lt;/p&gt;
&lt;p&gt;新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。&lt;/p&gt;
&lt;h2&gt;10. Redis 持久化有几种方式？&lt;/h2&gt;
&lt;p&gt;Redis 的持久化有两种方式，或者说有两种策略：&lt;/p&gt;
&lt;p&gt;RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。&lt;/p&gt;
&lt;p&gt;AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。&lt;/p&gt;
&lt;h2&gt;11. Redis 怎么实现分布式锁？&lt;/h2&gt;
&lt;p&gt;Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。&lt;/p&gt;
&lt;p&gt;占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。&lt;/p&gt;
&lt;h2&gt;12. Redis 分布式锁有什么缺陷？&lt;/h2&gt;
&lt;p&gt;Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。&lt;/p&gt;
&lt;h2&gt;13. Redis 如何做内存优化？&lt;/h2&gt;
&lt;p&gt;尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。&lt;/p&gt;
&lt;h2&gt;14. Redis 淘汰策略有哪些？&lt;/h2&gt;
&lt;p&gt;volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。&lt;/p&gt;
&lt;p&gt;volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。&lt;/p&gt;
&lt;p&gt;volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。&lt;/p&gt;
&lt;p&gt;allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。&lt;/p&gt;
&lt;p&gt;allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。&lt;/p&gt;
&lt;p&gt;no-enviction（驱逐）：禁止驱逐数据。&lt;/p&gt;
&lt;h2&gt;15. Redis 常见的性能问题有哪些？该如何解决？&lt;/h2&gt;
&lt;p&gt;主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。&lt;/p&gt;
&lt;p&gt;Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。&lt;/p&gt;
</content><link href="/archives/java-interview-redis/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-dubbo/</id><title>Java面试题-Dubbo</title><updated>2020-01-15T10:02:27.596822+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1.单例设计模式&lt;/h2&gt;
&lt;p&gt;使用设计模式为了代码复用，增加可维护性。&lt;/p&gt;
&lt;p&gt;设计模式的六大原则：开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、迪米特法则（最少知道原则）、合成/聚合复用原则&lt;/p&gt;
&lt;p&gt;Singleton（创建）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。如打印机&lt;/p&gt;
&lt;p&gt;饿汉式单例模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//饿汉模式：线程安全，耗费资源。
public class HugerSingletonTest {
    //该对象的引用不可修改。还可以将对象的创建放到静态代码块中。
    private static final HugerSingletonTest ourInstance = new HugerSingletonTest();

    public static HugerSingletonTest getInstance() {
        return ourInstance;
    }
    private HugerSingletonTest() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式：非线程安全&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static Singleton ourInstance;

    public static Singleton getInstance() {
        if (null == ourInstance) {
            ourInstance = new Singleton();
        }
        return ourInstance;
    }
    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式，线程安全：给方法加锁，消耗资源。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static Singleton ourInstance;

    public synchronized static Singleton getInstance() {
        if (null == ourInstance) {
            ourInstance = new Singleton();
        }
        return ourInstance;
    }
    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式，线程安全：双重检查锁。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static Singleton ourInstance;

    public synchronized static Singleton getInstance() {
        if (null == ourInstance) {
            synchronized (Singleton.class) {
                if (null == ourInstance) {
                    ourInstance = new Singleton();
                }
            }
        }
        return ourInstance;
    }
    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：
JVM会进行指令重排序，原本的步骤应该是先给 singleton 分配内存，然后调用 Singleton 的构造函数来初始化成员变量，形成实例，最后将singleton对象指向分配的内存空间，但有可能步骤会打乱，就会出现实例非空但没有初始化，抛出异常。将singleton声明成 volatile ，就可以解决该问题。&lt;/p&gt;
&lt;p&gt;懒汉式，线程安全：静态内部类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static class SingletonHodler {
        private static Singleton ourInstance = new Singleton();
    }

    public synchronized static Singleton getInstance() {
        return SingletonHodler.ourInstance;
    }

    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式，线程安全：枚举&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum SingletonTest {  
    INSTANCE;  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单例模式在JDK8源码中的使用：Runtime.getRuntime()方法（饿汉式单例模式）&lt;/p&gt;
&lt;h2&gt;2.适配器设计模式&lt;/h2&gt;
&lt;p&gt;适配器模式（结构）中的角色：目标接口（Target）：客户所期待的接口、需要适配的类（Adaptee）、适配器（Adapter）。&lt;/p&gt;
&lt;p&gt;对象适配器（采用对象组合方式实现）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//适配器类实现了目标接口
public class Adapter implements Target{
    private Adaptee adaptee ;
    public Adapter() {
        super();
        this.adaptee = new Adaptee();
    }
    @Override
    public void getHeadset2() {
        adaptee.getHeadset3();
    }
    public static void main(String args[]){
        Target target = new Adapter();
        //表面上调用的是2孔插座方法，但其实调用的三孔插座方法。
        target.getHeadset2();
    }
}
interface Target{
    //两孔插座
    void getHeadset2();
}
class Adaptee{
    public void getHeadset3(){
        System.out.println("我是三孔插座！");
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;适配器模式在JDK源码的使用&lt;/p&gt;
&lt;p&gt;Arrays.asList()，其中Arrays是目标类，内部类ArrayList是适配器类，而Objects.requireNonNull(array);需要适配的类。&lt;/p&gt;
&lt;p&gt;InputStreamReader .read()，其中Reader 是目标类，InputStreamReader是适配器类，而StreamDecoder 是需要适配的类。&lt;/p&gt;
&lt;h2&gt;3.模板方法设计模式&lt;/h2&gt;
&lt;p&gt;模板方法设计模式（行为）使用了继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）&lt;/p&gt;
&lt;p&gt;模板方法设计模式在JDK源码的使用:Collections.sort()、InputStream.read()等&lt;/p&gt;
</content><link href="/archives/java-interview-dubbo/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-mysql/</id><title>Java面试题-MySQL</title><updated>2020-01-15T10:02:27.596805+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. 数据库的三范式是什么？&lt;/h2&gt;
&lt;p&gt;第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。&lt;/p&gt;
&lt;p&gt;第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。&lt;/p&gt;
&lt;p&gt;第三范式：任何非主属性不依赖于其它非主属性。&lt;/p&gt;
&lt;h2&gt;2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？&lt;/h2&gt;
&lt;p&gt;表类型如果是 MyISAM ，那 id 就是 8。&lt;/p&gt;
&lt;p&gt;表类型如果是 InnoDB，那 id 就是 6。&lt;/p&gt;
&lt;p&gt;InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。&lt;/p&gt;
&lt;h2&gt;3. 如何获取当前数据库版本？&lt;/h2&gt;
&lt;p&gt;使用 select version() 获取当前 MySQL 数据库版本。&lt;/p&gt;
&lt;h2&gt;4. 说一下 ACID 是什么？&lt;/h2&gt;
&lt;p&gt;Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。&lt;/p&gt;
&lt;p&gt;Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。&lt;/p&gt;
&lt;p&gt;Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/p&gt;
&lt;p&gt;Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/p&gt;
&lt;h2&gt;5. char 和 varchar 的区别是什么？&lt;/h2&gt;
&lt;p&gt;char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。&lt;/p&gt;
&lt;p&gt;chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。&lt;/p&gt;
&lt;p&gt;varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。&lt;/p&gt;
&lt;p&gt;所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。&lt;/p&gt;
&lt;h2&gt;6. float 和 double 的区别是什么？&lt;/h2&gt;
&lt;p&gt;float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。&lt;/p&gt;
&lt;p&gt;double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。&lt;/p&gt;
&lt;h2&gt;7. MySQL 的内连接、左连接、右连接有什么区别？&lt;/h2&gt;
&lt;p&gt;内连接关键字：inner join；左连接：left join；右连接：right join。&lt;/p&gt;
&lt;p&gt;内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。&lt;/p&gt;
&lt;h2&gt;8. MySQL 索引是怎么实现的？&lt;/h2&gt;
&lt;p&gt;索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。&lt;/p&gt;
&lt;p&gt;具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。&lt;/p&gt;
&lt;h2&gt;9. 怎么验证 MySQL 的索引是否满足需求？&lt;/h2&gt;
&lt;p&gt;使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。&lt;/p&gt;
&lt;p&gt;explain 语法：explain select * from table where type=1。&lt;/p&gt;
&lt;h2&gt;10. 说一下数据库的事务隔离？&lt;/h2&gt;
&lt;p&gt;MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：&lt;/p&gt;
&lt;p&gt;transaction-isolation = REPEATABLE-READ&lt;/p&gt;
&lt;p&gt;可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。&lt;/p&gt;
&lt;p&gt;READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。&lt;/p&gt;
&lt;p&gt;READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。&lt;/p&gt;
&lt;p&gt;REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。&lt;/p&gt;
&lt;p&gt;SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。&lt;/p&gt;
&lt;p&gt;脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。&lt;/p&gt;
&lt;p&gt;不可重复读 ：是指在一个事务内，多次读同一数据。&lt;/p&gt;
&lt;p&gt;幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。&lt;/p&gt;
&lt;h2&gt;11. 说一下 MySQL 常用的引擎？&lt;/h2&gt;
&lt;p&gt;InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。&lt;/p&gt;
&lt;p&gt;MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。&lt;/p&gt;
&lt;h2&gt;12. 说一下 MySQL 的行锁和表锁？&lt;/h2&gt;
&lt;p&gt;MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。&lt;/p&gt;
&lt;p&gt;表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。&lt;/p&gt;
&lt;p&gt;行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。&lt;/p&gt;
&lt;h2&gt;13. 说一下乐观锁和悲观锁？&lt;/h2&gt;
&lt;p&gt;乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。&lt;/p&gt;
&lt;p&gt;悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。&lt;/p&gt;
&lt;p&gt;数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。&lt;/p&gt;
&lt;h2&gt;14. MySQL 问题排查都有哪些手段？&lt;/h2&gt;
&lt;p&gt;使用 show processlist 命令查看当前所有连接信息。&lt;/p&gt;
&lt;p&gt;使用 explain 命令查询 SQL 语句执行计划。&lt;/p&gt;
&lt;p&gt;开启慢查询日志，查看慢查询的 SQL。&lt;/p&gt;
&lt;h2&gt;15. 如何做 MySQL 的性能优化？&lt;/h2&gt;
&lt;p&gt;为搜索字段创建索引。&lt;/p&gt;
&lt;p&gt;避免使用 select *，列出需要查询的字段。&lt;/p&gt;
&lt;p&gt;垂直分割分表。&lt;/p&gt;
&lt;p&gt;选择正确的存储引擎。&lt;/p&gt;
</content><link href="/archives/java-interview-mysql/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-mybatis/</id><title>Java面试题-MyBatis</title><updated>2020-01-15T10:02:27.596788+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. MyBatis 中 #{}和 ${}的区别是什么？&lt;/h2&gt;
&lt;h1&gt;{}是预编译处理，${}是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的#{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。&lt;/h1&gt;
&lt;h2&gt;2. MyBatis 有几种分页方式？&lt;/h2&gt;
&lt;p&gt;分页方式：逻辑分页和物理分页。&lt;/p&gt;
&lt;p&gt;逻辑分页：使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。&lt;/p&gt;
&lt;p&gt;物理分页：自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。&lt;/p&gt;
&lt;h2&gt;3. RowBounds 是一次性查询全部结果吗？为什么？&lt;/h2&gt;
&lt;p&gt;RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。&lt;/p&gt;
&lt;p&gt;就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。&lt;/p&gt;
&lt;h2&gt;4. MyBatis 逻辑分页和物理分页的区别是什么？&lt;/h2&gt;
&lt;p&gt;逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。&lt;/p&gt;
&lt;p&gt;物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。&lt;/p&gt;
&lt;h2&gt;5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？&lt;/h2&gt;
&lt;p&gt;MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。&lt;/p&gt;
&lt;p&gt;延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。&lt;/p&gt;
&lt;h2&gt;6. 说一下 MyBatis 的一级缓存和二级缓存？&lt;/h2&gt;
&lt;p&gt;一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。&lt;/p&gt;
&lt;p&gt;当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。&lt;/p&gt;
&lt;p&gt;二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。&lt;/p&gt;
&lt;p&gt;开启二级缓存数据查询流程：二级缓存 -&amp;gt; 一级缓存 -&amp;gt; 数据库。&lt;/p&gt;
&lt;p&gt;缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。&lt;/p&gt;
&lt;h2&gt;7. MyBatis 和 hibernate 的区别有哪些？&lt;/h2&gt;
&lt;p&gt;灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。&lt;/p&gt;
&lt;p&gt;可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。&lt;/p&gt;
&lt;p&gt;学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。&lt;/p&gt;
&lt;p&gt;二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。&lt;/p&gt;
&lt;h2&gt;8. MyBatis 有哪些执行器（Executor）？&lt;/h2&gt;
&lt;p&gt;MyBatis 有三种基本的Executor执行器：&lt;/p&gt;
&lt;p&gt;SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；&lt;/p&gt;
&lt;p&gt;ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；&lt;/p&gt;
&lt;p&gt;BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。&lt;/p&gt;
&lt;h2&gt;9. MyBatis 分页插件的实现原理是什么？&lt;/h2&gt;
&lt;p&gt;分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。&lt;/p&gt;
&lt;h2&gt;10. MyBatis 如何编写一个自定义插件？&lt;/h2&gt;
&lt;p&gt;自定义插件实现原理&lt;/p&gt;
&lt;p&gt;MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：&lt;/p&gt;
&lt;p&gt;Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；&lt;/p&gt;
&lt;p&gt;StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；&lt;/p&gt;
&lt;p&gt;ParameterHandler：拦截参数的处理；&lt;/p&gt;
&lt;p&gt;ResultSetHandler：拦截结果集的处理。&lt;/p&gt;
&lt;p&gt;自定义插件实现关键&lt;/p&gt;
&lt;p&gt;MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public interface Interceptor {

      Object intercept(Invocation invocation) throws Throwable;

      Object plugin(Object target);

      void setProperties(Properties properties);

    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；&lt;/p&gt;
&lt;p&gt;plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；&lt;/p&gt;
&lt;p&gt;intercept 方法就是要进行拦截的时候要执行的方法。&lt;/p&gt;
&lt;p&gt;自定义插件实现示例&lt;/p&gt;
&lt;p&gt;官方插件实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Intercepts({@Signature(type = Executor. class, method = "query",

    args = {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})

    public class TestInterceptor implements Interceptor {

        public Object intercept(Invocation invocation) throws Throwable {

          Object target = invocation. getTarget(); //被代理对象

          Method method = invocation. getMethod(); //代理方法

          Object[] args = invocation. getArgs(); //方法参数

          // do something . . . . . .  方法拦截前执行代码块

          Object result = invocation. proceed();

          // do something . . . . . . . 方法拦截后执行代码块

          return result;

        }

        public Object plugin(Object target) {

          return Plugin. wrap(target, this);

        }

    }&lt;/code&gt;&lt;/pre&gt;
</content><link href="/archives/java-interview-mybatis/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-dubbo/</id><title>Java面试题-Dubbo</title><updated>2020-01-15T10:02:27.596770+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1、测试和生产共用一套zookeeper，怎么保证消费不冲突 ？&lt;/h2&gt;
&lt;p&gt;方案1：服务发布的group设置为不同；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;dubbo:reference id="comm1" timeout="100000" interface="com.acq.facade.CommService" group="comm102" version="1.0.0" retries="0" check="false"&amp;gt;
  &amp;lt;/dubbo:reference&amp;gt;

  &amp;lt;dubbo:reference id="comm2" timeout="100000" interface="com.acq.facade.CommService" group="comm103" version="1.0.0" retries="0" check="false"&amp;gt;
  &amp;lt;/dubbo:reference&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface="com.foo.BarService" version="1.0.0" &amp;gt;&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案3：dubbo白名单（Filter过滤器）&lt;/p&gt;
&lt;p&gt;1.新增一个类继承阿里巴巴的Filter&lt;/p&gt;
&lt;p&gt;2.添加阿里巴巴的约定新建配置文件 com.alibaba.dubbo.rpc.Filter，指定上面的类&lt;/p&gt;
&lt;p&gt;3.配置ip白名单&lt;/p&gt;
&lt;p&gt;4.配置服务端dubbo配置&lt;/p&gt;
&lt;h2&gt;2、dubbo运行时,突然所有的zookeeper全部宕机,dubbo是否还会继续提供服务？&lt;/h2&gt;
&lt;p&gt;会的，dubbo根据本地缓存的服务地址进行服务调用&lt;/p&gt;
&lt;p&gt;监控中心宕掉不影响使用，只是丢失部分采样数据&lt;/p&gt;
&lt;p&gt;数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务&lt;/p&gt;
&lt;p&gt;注册中心对等集群，任意一台宕掉后，将自动切换到另一台&lt;/p&gt;
&lt;p&gt;注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯&lt;/p&gt;
&lt;p&gt;服务提供者无状态，任意一台宕掉后，不影响使用&lt;/p&gt;
&lt;p&gt;服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复&lt;/p&gt;
&lt;h2&gt;3、服务提供者能实现失效踢出是什么原理？&lt;/h2&gt;
&lt;p&gt;基于zookeeper的临时节点原理&lt;/p&gt;
&lt;p&gt;持久节点&lt;/p&gt;
&lt;p&gt;所谓持久节点,是指在节点创建后,就一直存在,直到有删除操作来主动清除这个节点,也就是说不会因为创建该节点的客户端会话失效而消失&lt;/p&gt;
&lt;p&gt;临时节点&lt;/p&gt;
&lt;p&gt;临时节点的生命周期和客户端会话绑定,也就是说,如果客户端会话失效,那么这个节点就会自动被清除掉&lt;/p&gt;
&lt;h2&gt;4、创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？&lt;/h2&gt;
&lt;p&gt;连接断了之后，ZK不会马上移除临时数据，只有当SESSIONEXPIRED之后，才会把这个会话建立的临时数据移除。因此，用户需要谨慎设置Session_TimeOut&lt;/p&gt;
&lt;h2&gt;5、Dubbo在安全机制方面是如何解决的 ？&lt;/h2&gt;
&lt;p&gt;Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。&lt;/p&gt;
&lt;h2&gt;6、说说核心的配置有哪些？&lt;/h2&gt;
&lt;p&gt;dubbo:service/ 服务提供者暴露服务配置&lt;/p&gt;
&lt;p&gt;dubbo:reference/ 服务消费者引用服务配置&lt;/p&gt;
&lt;p&gt;dubbo:protocol/ 服务提供者协议配置&lt;/p&gt;
&lt;p&gt;dubbo:registry/ 注册中心配置&lt;/p&gt;
&lt;p&gt;dubbo:application/ 应用信息配置&lt;/p&gt;
&lt;p&gt;dubbo:provider/ 服务提供者缺省值配置&lt;/p&gt;
&lt;p&gt;dubbo:consumer/ 服务消费者缺省值配置&lt;/p&gt;
&lt;p&gt;dubbo:method/ 方法级配置&lt;/p&gt;
</content><link href="/archives/java-interview-dubbo/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-thread/</id><title>Java面试题-多线程</title><updated>2020-01-15T10:02:27.596750+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1.为什么要使用线程池&lt;/h2&gt;
&lt;p&gt;避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。&lt;/p&gt;
&lt;h2&gt;2.java中如何获取到线程dump文件&lt;/h2&gt;
&lt;p&gt;死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java

2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。&lt;/p&gt;
&lt;h2&gt;3.怎么检测一个线程是否持有对象监视器&lt;/h2&gt;
&lt;p&gt;我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。&lt;/p&gt;
&lt;h2&gt;4.synchronized和ReentrantLock的区别&lt;/h2&gt;
&lt;p&gt;synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁

（2）ReentrantLock可以获取各种锁的信息

（3）ReentrantLock可以灵活地实现多路通知

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。&lt;/p&gt;
&lt;h2&gt;5.ConcurrentHashMap的并发度是什么&lt;/h2&gt;
&lt;p&gt;ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？&lt;/p&gt;
&lt;h2&gt;6.ReentrantLock是什么&lt;/h2&gt;
&lt;p&gt;首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。&lt;/p&gt;
&lt;p&gt;因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。&lt;/p&gt;
&lt;h2&gt;7.FutureTask是什么&lt;/h2&gt;
&lt;p&gt;这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。&lt;/p&gt;
&lt;h2&gt;8.Linux环境下如何查找哪个线程使用CPU最长&lt;/h2&gt;
&lt;p&gt;这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：&lt;/p&gt;
&lt;p&gt;（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过&lt;/p&gt;
&lt;p&gt;（2）top -H -p pid，顺序不能改变&lt;/p&gt;
&lt;p&gt;这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。&lt;/p&gt;
&lt;p&gt;使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。&lt;/p&gt;
&lt;p&gt;最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。&lt;/p&gt;
&lt;h2&gt;9.一个线程如果出现了运行时异常会怎么样&lt;/h2&gt;
&lt;p&gt;如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放&lt;/p&gt;
&lt;h2&gt;10.如何在两个线程之间共享数据&lt;/h2&gt;
&lt;p&gt;通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的&lt;/p&gt;
&lt;h2&gt;11. 线程和进程的区别？&lt;/h2&gt;
&lt;p&gt;一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。&lt;/p&gt;
&lt;h2&gt;12. 守护线程是什么？&lt;/h2&gt;
&lt;p&gt;守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。&lt;/p&gt;
&lt;h2&gt;13. 创建线程有哪几种方式？&lt;/h2&gt;
&lt;p&gt;创建线程有三种方式：&lt;/p&gt;
&lt;p&gt;继承 Thread 重新 run 方法；&lt;/p&gt;
&lt;p&gt;实现 Runnable 接口；&lt;/p&gt;
&lt;p&gt;实现 Callable 接口。&lt;/p&gt;
&lt;h2&gt;14. 说一下 runnable 和 callable 有什么区别？&lt;/h2&gt;
&lt;p&gt;runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。&lt;/p&gt;
&lt;h2&gt;15. 线程有哪些状态？&lt;/h2&gt;
&lt;p&gt;线程的状态：&lt;/p&gt;
&lt;p&gt;NEW 尚未启动&lt;/p&gt;
&lt;p&gt;RUNNABLE 正在执行中&lt;/p&gt;
&lt;p&gt;BLOCKED 阻塞的（被同步锁或者IO锁阻塞）&lt;/p&gt;
&lt;p&gt;WAITING 永久等待状态&lt;/p&gt;
&lt;p&gt;TIMED_WAITING 等待指定的时间重新被唤醒的状态&lt;/p&gt;
&lt;p&gt;TERMINATED 执行完成&lt;/p&gt;
&lt;h2&gt;16. sleep() 和 wait() 有什么区别？&lt;/h2&gt;
&lt;p&gt;类的不同：sleep() 来自 Thread，wait() 来自 Object。&lt;/p&gt;
&lt;p&gt;释放锁：sleep() 不释放锁；wait() 释放锁。&lt;/p&gt;
&lt;p&gt;用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。&lt;/p&gt;
&lt;h2&gt;17. notify()和 notifyAll()有什么区别？&lt;/h2&gt;
&lt;p&gt;notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。&lt;/p&gt;
&lt;h2&gt;18. 线程的 run() 和 start() 有什么区别？&lt;/h2&gt;
&lt;p&gt;start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。&lt;/p&gt;
&lt;h2&gt;19. 创建线程池有哪几种方式？&lt;/h2&gt;
&lt;p&gt;线程池创建有七种方式，最核心的是最后一种：&lt;/p&gt;
&lt;p&gt;newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；&lt;/p&gt;
&lt;p&gt;newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；&lt;/p&gt;
&lt;p&gt;newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；&lt;/p&gt;
&lt;p&gt;newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；&lt;/p&gt;
&lt;p&gt;newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；&lt;/p&gt;
&lt;p&gt;newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。&lt;/p&gt;
&lt;h2&gt;20. 线程池都有哪些状态？&lt;/h2&gt;
&lt;p&gt;RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。&lt;/p&gt;
&lt;p&gt;SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。&lt;/p&gt;
&lt;p&gt;STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。&lt;/p&gt;
&lt;p&gt;TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。&lt;/p&gt;
&lt;p&gt;TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。&lt;/p&gt;
&lt;h2&gt;21. 线程池中 submit() 和 execute() 方法有什么区别？&lt;/h2&gt;
&lt;p&gt;execute()：只能执行 Runnable 类型的任务。&lt;/p&gt;
&lt;p&gt;submit()：可以执行 Runnable 和 Callable 类型的任务。&lt;/p&gt;
&lt;p&gt;Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。&lt;/p&gt;
&lt;h2&gt;22. 在 Java 程序中怎么保证多线程的运行安全？&lt;/h2&gt;
&lt;p&gt;方法一：使用安全类，比如 Java. util. concurrent 下的类。&lt;/p&gt;
&lt;p&gt;方法二：使用自动锁 synchronized。&lt;/p&gt;
&lt;p&gt;方法三：使用手动锁 Lock。&lt;/p&gt;
&lt;p&gt;手动锁 Java 示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Lock lock = new ReentrantLock();

    lock. lock();

    try {

    System. out. println("获得锁");

    } catch (Exception e) {

    // TODO: handle exception

    } finally {

    System. out. println("释放锁");

    lock. unlock();

    }&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;23. 多线程中 synchronized 锁升级的原理是什么？&lt;/h2&gt;
&lt;p&gt;synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致。&lt;/p&gt;
&lt;p&gt;如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。&lt;/p&gt;
&lt;p&gt;锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。&lt;/p&gt;
&lt;h2&gt;24. 什么是死锁？&lt;/h2&gt;
&lt;p&gt;当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。&lt;/p&gt;
&lt;h2&gt;25. 怎么防止死锁？&lt;/h2&gt;
&lt;p&gt;尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。&lt;/p&gt;
&lt;p&gt;尽量使用 Java. util. concurrent 并发类代替自己手写锁。&lt;/p&gt;
&lt;p&gt;尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。&lt;/p&gt;
&lt;p&gt;尽量减少同步的代码块。&lt;/p&gt;
&lt;h2&gt;26. ThreadLocal 是什么？有哪些使用场景？&lt;/h2&gt;
&lt;p&gt;ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;
&lt;p&gt;ThreadLocal 的经典使用场景是数据库连接和 session 管理等。&lt;/p&gt;
&lt;h2&gt;27. 说一下 synchronized 底层实现原理？&lt;/h2&gt;
&lt;p&gt;synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。&lt;/p&gt;
&lt;p&gt;在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。&lt;/p&gt;
&lt;p&gt;但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。&lt;/p&gt;
&lt;h2&gt;28. synchronized 和 volatile 的区别是什么？&lt;/h2&gt;
&lt;p&gt;volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。&lt;/p&gt;
&lt;p&gt;volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。&lt;/p&gt;
&lt;p&gt;volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。&lt;/p&gt;
&lt;h2&gt;29. synchronized 和 Lock 有什么区别？&lt;/h2&gt;
&lt;p&gt;synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。&lt;/p&gt;
&lt;p&gt;synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。&lt;/p&gt;
&lt;p&gt;通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。&lt;/p&gt;
&lt;h2&gt;30. synchronized 和 ReentrantLock 区别是什么？&lt;/h2&gt;
&lt;p&gt;synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。&lt;/p&gt;
&lt;p&gt;主要区别如下：&lt;/p&gt;
&lt;p&gt;ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；&lt;/p&gt;
&lt;p&gt;ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；&lt;/p&gt;
&lt;p&gt;ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。&lt;/p&gt;
&lt;p&gt;volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。&lt;/p&gt;
&lt;h2&gt;31. 说一下 atomic 的原理？&lt;/h2&gt;
&lt;p&gt;atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。&lt;/p&gt;
&lt;h2&gt;32.线程类的构造方法，静态块是哪个线程调用的&lt;/h2&gt;
&lt;p&gt;这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。&lt;/p&gt;
&lt;p&gt;如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：&lt;/p&gt;
&lt;p&gt;1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的&lt;/p&gt;
&lt;p&gt;2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的&lt;/p&gt;
&lt;h2&gt;33.同步方法和同步块，哪个是更好的选择&lt;/h2&gt;
&lt;p&gt;同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。&lt;/p&gt;
&lt;p&gt;借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。&lt;/p&gt;
&lt;p&gt;这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&amp;gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换。&lt;/p&gt;
&lt;p&gt;因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&amp;gt;解锁的次数，有效地提升了代码执行的效率。&lt;/p&gt;
&lt;h2&gt;34.高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？&lt;/h2&gt;
&lt;p&gt;这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：&lt;/p&gt;
&lt;p&gt;1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换&lt;/p&gt;
&lt;p&gt;2）并发不高、任务执行时间长的业务要区分开看：&lt;/p&gt;
&lt;p&gt;a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务&lt;/p&gt;
&lt;p&gt;b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换&lt;/p&gt;
&lt;p&gt;c）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。&lt;/p&gt;
</content><link href="/archives/java-interview-thread/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-jvm/</id><title>Java面试题-JVM</title><updated>2020-01-15T10:02:27.596710+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. 说一下 JVM 的主要组成部分？及其作用？&lt;/h2&gt;
&lt;p&gt;类加载器（ClassLoader）&lt;/p&gt;
&lt;p&gt;运行时数据区（Runtime Data Area）&lt;/p&gt;
&lt;p&gt;执行引擎（Execution Engine）&lt;/p&gt;
&lt;p&gt;本地库接口（Native Interface）&lt;/p&gt;
&lt;p&gt;组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。&lt;/p&gt;
&lt;h2&gt;2. 说一下 JVM 运行时数据区？&lt;/h2&gt;
&lt;p&gt;不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：&lt;/p&gt;
&lt;p&gt;程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；&lt;/p&gt;
&lt;p&gt;Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；&lt;/p&gt;
&lt;p&gt;本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；&lt;/p&gt;
&lt;p&gt;Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；&lt;/p&gt;
&lt;p&gt;方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。&lt;/p&gt;
&lt;h2&gt;3. 说一下堆栈的区别？&lt;/h2&gt;
&lt;p&gt;功能方面：堆是用来存放对象的，栈是用来执行程序的。&lt;/p&gt;
&lt;p&gt;共享性：堆是线程共享的，栈是线程私有的。&lt;/p&gt;
&lt;p&gt;空间大小：堆大小远远大于栈。&lt;/p&gt;
&lt;h2&gt;4. 队列和栈是什么？有什么区别？&lt;/h2&gt;
&lt;p&gt;队列和栈都是被用来预存储数据的。&lt;/p&gt;
&lt;p&gt;队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。&lt;/p&gt;
&lt;p&gt;栈和队列很相似，但它运行对元素进行后进先出进行检索。&lt;/p&gt;
&lt;h2&gt;5. 什么是双亲委派模型？&lt;/h2&gt;
&lt;p&gt;在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。&lt;/p&gt;
&lt;p&gt;类加载器分类：&lt;/p&gt;
&lt;p&gt;启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；&lt;/p&gt;
&lt;p&gt;其他类加载器：&lt;/p&gt;
&lt;p&gt;扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/p&gt;
&lt;p&gt;应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。&lt;/p&gt;
&lt;p&gt;双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。&lt;/p&gt;
&lt;h2&gt;6. 说一下类装载的执行过程？&lt;/h2&gt;
&lt;p&gt;类装载分为以下 5 个步骤：&lt;/p&gt;
&lt;p&gt;加载：根据查找路径找到相应的 class 文件然后导入；&lt;/p&gt;
&lt;p&gt;检查：检查加载的 class 文件的正确性；&lt;/p&gt;
&lt;p&gt;准备：给类中的静态变量分配内存空间；&lt;/p&gt;
&lt;p&gt;解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；&lt;/p&gt;
&lt;p&gt;初始化：对静态变量和静态代码块执行初始化工作。&lt;/p&gt;
&lt;h2&gt;7. 怎么判断对象是否可以被回收？&lt;/h2&gt;
&lt;p&gt;一般有两种方法来判断：&lt;/p&gt;
&lt;p&gt;引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；&lt;/p&gt;
&lt;p&gt;可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。&lt;/p&gt;
&lt;h2&gt;8. Java 中都有哪些引用类型？&lt;/h2&gt;
&lt;p&gt;强引用：发生 gc 的时候不会被回收。&lt;/p&gt;
&lt;p&gt;软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。&lt;/p&gt;
&lt;p&gt;弱引用：有用但不是必须的对象，在下一次GC时会被回收。&lt;/p&gt;
&lt;p&gt;虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。&lt;/p&gt;
&lt;h2&gt;9. 说一下 JVM 有哪些垃圾回收算法？&lt;/h2&gt;
&lt;p&gt;标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。&lt;/p&gt;
&lt;p&gt;标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。&lt;/p&gt;
&lt;p&gt;复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。&lt;/p&gt;
&lt;p&gt;分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。&lt;/p&gt;
&lt;h2&gt;10. 说一下 JVM 有哪些垃圾回收器？&lt;/h2&gt;
&lt;p&gt;Serial：最早的单线程串行垃圾回收器。&lt;/p&gt;
&lt;p&gt;Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。&lt;/p&gt;
&lt;p&gt;ParNew：是 Serial 的多线程版本。&lt;/p&gt;
&lt;p&gt;Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。&lt;/p&gt;
&lt;p&gt;Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。&lt;/p&gt;
&lt;p&gt;CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。&lt;/p&gt;
&lt;p&gt;G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。&lt;/p&gt;
&lt;h2&gt;11. 详细介绍一下 CMS 垃圾回收器？&lt;/h2&gt;
&lt;p&gt;CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。&lt;/p&gt;
&lt;p&gt;CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。&lt;/p&gt;
&lt;h2&gt;12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？&lt;/h2&gt;
&lt;p&gt;新生代回收器：Serial、ParNew、Parallel Scavenge&lt;/p&gt;
&lt;p&gt;老年代回收器：Serial Old、Parallel Old、CMS&lt;/p&gt;
&lt;p&gt;整堆回收器：G1&lt;/p&gt;
&lt;p&gt;新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。&lt;/p&gt;
&lt;h2&gt;13. 简述分代垃圾回收器是怎么工作的？&lt;/h2&gt;
&lt;p&gt;分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。&lt;/p&gt;
&lt;p&gt;新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：&lt;/p&gt;
&lt;p&gt;把 Eden + From Survivor 存活的对象放入 To Survivor 区；&lt;/p&gt;
&lt;p&gt;清空 Eden 和 From Survivor 分区；&lt;/p&gt;
&lt;p&gt;From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。&lt;/p&gt;
&lt;p&gt;每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。&lt;/p&gt;
&lt;p&gt;老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。&lt;/p&gt;
&lt;h2&gt;14. 说一下 JVM 调优的工具？&lt;/h2&gt;
&lt;p&gt;JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。&lt;/p&gt;
&lt;p&gt;jconsole：用于对 JVM 中的内存、线程和类等进行监控；&lt;/p&gt;
&lt;p&gt;jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。&lt;/p&gt;
&lt;h2&gt;15. 常用的 JVM 调优的参数都有哪些？&lt;/h2&gt;
&lt;p&gt;-Xms2g：初始化推大小为 2g；&lt;/p&gt;
&lt;p&gt;-Xmx2g：堆最大内存为 2g；&lt;/p&gt;
&lt;p&gt;-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；&lt;/p&gt;
&lt;p&gt;-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；&lt;/p&gt;
&lt;p&gt;–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；&lt;/p&gt;
&lt;p&gt;-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；&lt;/p&gt;
&lt;p&gt;-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；&lt;/p&gt;
&lt;p&gt;-XX:+PrintGC：开启打印 gc 信息；&lt;/p&gt;
&lt;p&gt;-XX:+PrintGCDetails：打印 gc 详细信息。&lt;/p&gt;
</content><link href="/archives/java-interview-jvm/" rel="alternate"/><published>2020-01-11T12:00:00+08:06</published></entry></feed>