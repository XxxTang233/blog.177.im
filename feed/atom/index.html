<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>/</id><title>177博客</title><updated>2020-01-16T02:08:27.809152+08:06</updated><author><name>177</name><email>0@177.im</email></author><link href="/" rel="alternate"/><generator uri="http://lkiesow.github.io/python-feedgen" version="0.8.0">python-feedgen</generator><logo>${static_prefix}favicon.ico</logo><subtitle>天青色等烟雨</subtitle><entry><id>/archives/java-interview-jvm/</id><title>Java面试题-JVM</title><updated>2020-01-16T02:08:27.809492+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. 说一下 JVM 的主要组成部分？及其作用？&lt;/h2&gt;
&lt;p&gt;类加载器（ClassLoader）&lt;/p&gt;
&lt;p&gt;运行时数据区（Runtime Data Area）&lt;/p&gt;
&lt;p&gt;执行引擎（Execution Engine）&lt;/p&gt;
&lt;p&gt;本地库接口（Native Interface）&lt;/p&gt;
&lt;p&gt;组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。&lt;/p&gt;
&lt;h2&gt;2. 说一下 JVM 运行时数据区？&lt;/h2&gt;
&lt;p&gt;不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：&lt;/p&gt;
&lt;p&gt;程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；&lt;/p&gt;
&lt;p&gt;Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；&lt;/p&gt;
&lt;p&gt;本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；&lt;/p&gt;
&lt;p&gt;Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；&lt;/p&gt;
&lt;p&gt;方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。&lt;/p&gt;
&lt;h2&gt;3. 说一下堆栈的区别？&lt;/h2&gt;
&lt;p&gt;功能方面：堆是用来存放对象的，栈是用来执行程序的。&lt;/p&gt;
&lt;p&gt;共享性：堆是线程共享的，栈是线程私有的。&lt;/p&gt;
&lt;p&gt;空间大小：堆大小远远大于栈。&lt;/p&gt;
&lt;h2&gt;4. 队列和栈是什么？有什么区别？&lt;/h2&gt;
&lt;p&gt;队列和栈都是被用来预存储数据的。&lt;/p&gt;
&lt;p&gt;队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。&lt;/p&gt;
&lt;p&gt;栈和队列很相似，但它运行对元素进行后进先出进行检索。&lt;/p&gt;
&lt;h2&gt;5. 什么是双亲委派模型？&lt;/h2&gt;
&lt;p&gt;在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。&lt;/p&gt;
&lt;p&gt;类加载器分类：&lt;/p&gt;
&lt;p&gt;启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；&lt;/p&gt;
&lt;p&gt;其他类加载器：&lt;/p&gt;
&lt;p&gt;扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/p&gt;
&lt;p&gt;应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。&lt;/p&gt;
&lt;p&gt;双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。&lt;/p&gt;
&lt;h2&gt;6. 说一下类装载的执行过程？&lt;/h2&gt;
&lt;p&gt;类装载分为以下 5 个步骤：&lt;/p&gt;
&lt;p&gt;加载：根据查找路径找到相应的 class 文件然后导入；&lt;/p&gt;
&lt;p&gt;检查：检查加载的 class 文件的正确性；&lt;/p&gt;
&lt;p&gt;准备：给类中的静态变量分配内存空间；&lt;/p&gt;
&lt;p&gt;解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；&lt;/p&gt;
&lt;p&gt;初始化：对静态变量和静态代码块执行初始化工作。&lt;/p&gt;
&lt;h2&gt;7. 怎么判断对象是否可以被回收？&lt;/h2&gt;
&lt;p&gt;一般有两种方法来判断：&lt;/p&gt;
&lt;p&gt;引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；&lt;/p&gt;
&lt;p&gt;可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。&lt;/p&gt;
&lt;h2&gt;8. Java 中都有哪些引用类型？&lt;/h2&gt;
&lt;p&gt;强引用：发生 gc 的时候不会被回收。&lt;/p&gt;
&lt;p&gt;软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。&lt;/p&gt;
&lt;p&gt;弱引用：有用但不是必须的对象，在下一次GC时会被回收。&lt;/p&gt;
&lt;p&gt;虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。&lt;/p&gt;
&lt;h2&gt;9. 说一下 JVM 有哪些垃圾回收算法？&lt;/h2&gt;
&lt;p&gt;标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。&lt;/p&gt;
&lt;p&gt;标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。&lt;/p&gt;
&lt;p&gt;复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。&lt;/p&gt;
&lt;p&gt;分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。&lt;/p&gt;
&lt;h2&gt;10. 说一下 JVM 有哪些垃圾回收器？&lt;/h2&gt;
&lt;p&gt;Serial：最早的单线程串行垃圾回收器。&lt;/p&gt;
&lt;p&gt;Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。&lt;/p&gt;
&lt;p&gt;ParNew：是 Serial 的多线程版本。&lt;/p&gt;
&lt;p&gt;Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。&lt;/p&gt;
&lt;p&gt;Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。&lt;/p&gt;
&lt;p&gt;CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。&lt;/p&gt;
&lt;p&gt;G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。&lt;/p&gt;
&lt;h2&gt;11. 详细介绍一下 CMS 垃圾回收器？&lt;/h2&gt;
&lt;p&gt;CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。&lt;/p&gt;
&lt;p&gt;CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。&lt;/p&gt;
&lt;h2&gt;12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？&lt;/h2&gt;
&lt;p&gt;新生代回收器：Serial、ParNew、Parallel Scavenge&lt;/p&gt;
&lt;p&gt;老年代回收器：Serial Old、Parallel Old、CMS&lt;/p&gt;
&lt;p&gt;整堆回收器：G1&lt;/p&gt;
&lt;p&gt;新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。&lt;/p&gt;
&lt;h2&gt;13. 简述分代垃圾回收器是怎么工作的？&lt;/h2&gt;
&lt;p&gt;分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。&lt;/p&gt;
&lt;p&gt;新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：&lt;/p&gt;
&lt;p&gt;把 Eden + From Survivor 存活的对象放入 To Survivor 区；&lt;/p&gt;
&lt;p&gt;清空 Eden 和 From Survivor 分区；&lt;/p&gt;
&lt;p&gt;From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。&lt;/p&gt;
&lt;p&gt;每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。&lt;/p&gt;
&lt;p&gt;老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。&lt;/p&gt;
&lt;h2&gt;14. 说一下 JVM 调优的工具？&lt;/h2&gt;
&lt;p&gt;JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。&lt;/p&gt;
&lt;p&gt;jconsole：用于对 JVM 中的内存、线程和类等进行监控；&lt;/p&gt;
&lt;p&gt;jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。&lt;/p&gt;
&lt;h2&gt;15. 常用的 JVM 调优的参数都有哪些？&lt;/h2&gt;
&lt;p&gt;-Xms2g：初始化推大小为 2g；&lt;/p&gt;
&lt;p&gt;-Xmx2g：堆最大内存为 2g；&lt;/p&gt;
&lt;p&gt;-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；&lt;/p&gt;
&lt;p&gt;-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；&lt;/p&gt;
&lt;p&gt;–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；&lt;/p&gt;
&lt;p&gt;-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；&lt;/p&gt;
&lt;p&gt;-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；&lt;/p&gt;
&lt;p&gt;-XX:+PrintGC：开启打印 gc 信息；&lt;/p&gt;
&lt;p&gt;-XX:+PrintGCDetails：打印 gc 详细信息。&lt;/p&gt;
</content><link href="/archives/java-interview-jvm/" rel="alternate"/><published>2020-01-14T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-redis/</id><title>Java面试题-Redis</title><updated>2020-01-16T02:08:27.809473+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. Redis 是什么？都有哪些使用场景？&lt;/h2&gt;
&lt;p&gt;我们先来理解经典的CAP理论：&lt;/p&gt;
&lt;p&gt;一致性：是指从数据层面来看的一致性。&lt;/p&gt;
&lt;p&gt;可用性：是指从系统层面的可用性。&lt;/p&gt;
&lt;p&gt;容错性：是指从网络层面的的容错性。&lt;/p&gt;
&lt;p&gt;数据库逐渐从关系数据库向不同领域不同层次分化。随着读多写少场景的出现，导致需要读取数据的时间变慢，为了提升性能，出现了数据库缓存技术，对数据库的读取进行分离。web2.0时代，网民的生产力大增，存储总量也在增加，目前还是读多写少模式，原有的缓存技术显然不能满足写的压力，所以，出现了分库分表，实现读写分离。其中比较常用的一种缓存技术是用Redis做缓存。&lt;/p&gt;
&lt;p&gt;Redis是什么？&lt;/p&gt;
&lt;p&gt;Redis是一个基于内存且支持持久化的key-value的NoSQL数据库，其中每个key和value都是使用对象表示的，具有以以下特征：多样数据类型、持久化、主从同步。&lt;/p&gt;
&lt;p&gt;和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。&lt;/p&gt;
&lt;p&gt;在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的使用RDB快照的方式，把更新的数据写入磁盘或者使用类似MySQL的AOF日志方式把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。&lt;/p&gt;
&lt;p&gt;Redis3.0版本允许单点故障，它没有中心节点，各个节点地位一样，扩展性很好，节点间的采用二进制通信，节点与客户端采用ascII协议通信。&lt;/p&gt;
&lt;p&gt;综上所述，Redis可用于缓存、数据库、消息中间件。&lt;/p&gt;
&lt;p&gt;Redis 使用场景：&lt;/p&gt;
&lt;p&gt;记录帖子点赞数、点击数、评论数；&lt;/p&gt;
&lt;p&gt;缓存近期热帖；&lt;/p&gt;
&lt;p&gt;缓存文章详情信息；&lt;/p&gt;
&lt;p&gt;记录用户会话信息。&lt;/p&gt;
&lt;h2&gt;2. Redis 有哪些功能？&lt;/h2&gt;
&lt;p&gt;数据缓存功能&lt;/p&gt;
&lt;p&gt;分布式锁的功能&lt;/p&gt;
&lt;p&gt;支持数据持久化&lt;/p&gt;
&lt;p&gt;支持事务&lt;/p&gt;
&lt;p&gt;支持消息队列&lt;/p&gt;
&lt;h2&gt;3. Redis 和 memcache 有什么区别？&lt;/h2&gt;
&lt;p&gt;存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。&lt;/p&gt;
&lt;p&gt;数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。&lt;/p&gt;
&lt;p&gt;使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。&lt;/p&gt;
&lt;p&gt;value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。&lt;/p&gt;
&lt;h2&gt;4. Redis 为什么是单线程的？&lt;/h2&gt;
&lt;p&gt;因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。&lt;/p&gt;
&lt;p&gt;关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。&lt;/p&gt;
&lt;p&gt;而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。&lt;/p&gt;
&lt;h2&gt;5. 什么是缓存穿透？怎么解决？&lt;/h2&gt;
&lt;p&gt;缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。&lt;/p&gt;
&lt;p&gt;解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。&lt;/p&gt;
&lt;h2&gt;6. Redis 支持的数据类型有哪些？&lt;/h2&gt;
&lt;p&gt;Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。&lt;/p&gt;
&lt;h2&gt;7. Redis 支持的 Java 客户端都有哪些？&lt;/h2&gt;
&lt;p&gt;支持的 Java 客户端有 Redisson、jedis、lettuce 等。&lt;/p&gt;
&lt;h2&gt;8. jedis 和 Redisson 有哪些区别？&lt;/h2&gt;
&lt;p&gt;jedis：提供了比较全面的 Redis 命令的支持。&lt;/p&gt;
&lt;p&gt;Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。&lt;/p&gt;
&lt;h2&gt;9. 怎么保证缓存和数据库数据的一致性？&lt;/h2&gt;
&lt;p&gt;合理设置缓存的过期时间。&lt;/p&gt;
&lt;p&gt;新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。&lt;/p&gt;
&lt;h2&gt;10. Redis 持久化有几种方式？&lt;/h2&gt;
&lt;p&gt;Redis 的持久化有两种方式，或者说有两种策略：&lt;/p&gt;
&lt;p&gt;RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。&lt;/p&gt;
&lt;p&gt;AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。&lt;/p&gt;
&lt;h2&gt;11. Redis 怎么实现分布式锁？&lt;/h2&gt;
&lt;p&gt;Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。&lt;/p&gt;
&lt;p&gt;占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。&lt;/p&gt;
&lt;h2&gt;12. Redis 分布式锁有什么缺陷？&lt;/h2&gt;
&lt;p&gt;Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。&lt;/p&gt;
&lt;h2&gt;13. Redis 如何做内存优化？&lt;/h2&gt;
&lt;p&gt;尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。&lt;/p&gt;
&lt;h2&gt;14. Redis 淘汰策略有哪些？&lt;/h2&gt;
&lt;p&gt;volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。&lt;/p&gt;
&lt;p&gt;volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。&lt;/p&gt;
&lt;p&gt;volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。&lt;/p&gt;
&lt;p&gt;allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。&lt;/p&gt;
&lt;p&gt;allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。&lt;/p&gt;
&lt;p&gt;no-enviction（驱逐）：禁止驱逐数据。&lt;/p&gt;
&lt;h2&gt;15. Redis 常见的性能问题有哪些？该如何解决？&lt;/h2&gt;
&lt;p&gt;主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。&lt;/p&gt;
&lt;p&gt;Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。&lt;/p&gt;
</content><link href="/archives/java-interview-redis/" rel="alternate"/><published>2020-01-15T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-mysql/</id><title>Java面试题-MySQL</title><updated>2020-01-16T02:08:27.809455+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. 数据库的三范式是什么？&lt;/h2&gt;
&lt;p&gt;第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。&lt;/p&gt;
&lt;p&gt;第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。&lt;/p&gt;
&lt;p&gt;第三范式：任何非主属性不依赖于其它非主属性。&lt;/p&gt;
&lt;h2&gt;2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？&lt;/h2&gt;
&lt;p&gt;表类型如果是 MyISAM ，那 id 就是 8。&lt;/p&gt;
&lt;p&gt;表类型如果是 InnoDB，那 id 就是 6。&lt;/p&gt;
&lt;p&gt;InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。&lt;/p&gt;
&lt;h2&gt;3. 如何获取当前数据库版本？&lt;/h2&gt;
&lt;p&gt;使用 select version() 获取当前 MySQL 数据库版本。&lt;/p&gt;
&lt;h2&gt;4. 说一下 ACID 是什么？&lt;/h2&gt;
&lt;p&gt;Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。&lt;/p&gt;
&lt;p&gt;Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。&lt;/p&gt;
&lt;p&gt;Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/p&gt;
&lt;p&gt;Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/p&gt;
&lt;h2&gt;5. char 和 varchar 的区别是什么？&lt;/h2&gt;
&lt;p&gt;char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。&lt;/p&gt;
&lt;p&gt;chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。&lt;/p&gt;
&lt;p&gt;varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。&lt;/p&gt;
&lt;p&gt;所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。&lt;/p&gt;
&lt;h2&gt;6. float 和 double 的区别是什么？&lt;/h2&gt;
&lt;p&gt;float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。&lt;/p&gt;
&lt;p&gt;double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。&lt;/p&gt;
&lt;h2&gt;7. MySQL 的内连接、左连接、右连接有什么区别？&lt;/h2&gt;
&lt;p&gt;内连接关键字：inner join；左连接：left join；右连接：right join。&lt;/p&gt;
&lt;p&gt;内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。&lt;/p&gt;
&lt;h2&gt;8. MySQL 索引是怎么实现的？&lt;/h2&gt;
&lt;p&gt;索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。&lt;/p&gt;
&lt;p&gt;具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。&lt;/p&gt;
&lt;h2&gt;9. 怎么验证 MySQL 的索引是否满足需求？&lt;/h2&gt;
&lt;p&gt;使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。&lt;/p&gt;
&lt;p&gt;explain 语法：explain select * from table where type=1。&lt;/p&gt;
&lt;h2&gt;10. 说一下数据库的事务隔离？&lt;/h2&gt;
&lt;p&gt;MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：&lt;/p&gt;
&lt;p&gt;transaction-isolation = REPEATABLE-READ&lt;/p&gt;
&lt;p&gt;可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。&lt;/p&gt;
&lt;p&gt;READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。&lt;/p&gt;
&lt;p&gt;READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。&lt;/p&gt;
&lt;p&gt;REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。&lt;/p&gt;
&lt;p&gt;SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。&lt;/p&gt;
&lt;p&gt;脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。&lt;/p&gt;
&lt;p&gt;不可重复读 ：是指在一个事务内，多次读同一数据。&lt;/p&gt;
&lt;p&gt;幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。&lt;/p&gt;
&lt;h2&gt;11. 说一下 MySQL 常用的引擎？&lt;/h2&gt;
&lt;p&gt;InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。&lt;/p&gt;
&lt;p&gt;MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。&lt;/p&gt;
&lt;h2&gt;12. 说一下 MySQL 的行锁和表锁？&lt;/h2&gt;
&lt;p&gt;MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。&lt;/p&gt;
&lt;p&gt;表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。&lt;/p&gt;
&lt;p&gt;行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。&lt;/p&gt;
&lt;h2&gt;13. 说一下乐观锁和悲观锁？&lt;/h2&gt;
&lt;p&gt;乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。&lt;/p&gt;
&lt;p&gt;悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。&lt;/p&gt;
&lt;p&gt;数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。&lt;/p&gt;
&lt;h2&gt;14. MySQL 问题排查都有哪些手段？&lt;/h2&gt;
&lt;p&gt;使用 show processlist 命令查看当前所有连接信息。&lt;/p&gt;
&lt;p&gt;使用 explain 命令查询 SQL 语句执行计划。&lt;/p&gt;
&lt;p&gt;开启慢查询日志，查看慢查询的 SQL。&lt;/p&gt;
&lt;h2&gt;15. 如何做 MySQL 的性能优化？&lt;/h2&gt;
&lt;p&gt;为搜索字段创建索引。&lt;/p&gt;
&lt;p&gt;避免使用 select *，列出需要查询的字段。&lt;/p&gt;
&lt;p&gt;垂直分割分表。&lt;/p&gt;
&lt;p&gt;选择正确的存储引擎。&lt;/p&gt;
</content><link href="/archives/java-interview-mysql/" rel="alternate"/><published>2020-01-16T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-zookeeper/</id><title>Java面试题-Zookeeper</title><updated>2020-01-16T02:08:27.809437+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. zookeeper 是什么？&lt;/h2&gt;
&lt;p&gt;zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。&lt;/p&gt;
&lt;h2&gt;2. zookeeper 都有哪些功能？&lt;/h2&gt;
&lt;p&gt;集群管理：监控节点存活状态、运行请求等。&lt;/p&gt;
&lt;p&gt;主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。&lt;/p&gt;
&lt;p&gt;分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。&lt;/p&gt;
&lt;p&gt;命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。&lt;/p&gt;
&lt;h2&gt;3. zookeeper 有几种部署模式？&lt;/h2&gt;
&lt;p&gt;zookeeper 有三种部署模式：&lt;/p&gt;
&lt;p&gt;单机部署：一台集群上运行；&lt;/p&gt;
&lt;p&gt;集群部署：多台集群运行；&lt;/p&gt;
&lt;p&gt;伪集群部署：一台集群启动多个 zookeeper 实例运行。&lt;/p&gt;
&lt;h2&gt;4. zookeeper 怎么保证主从节点的状态同步？&lt;/h2&gt;
&lt;p&gt;zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。&lt;/p&gt;
&lt;p&gt;当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。&lt;/p&gt;
&lt;h2&gt;5. 集群中为什么要有主节点？&lt;/h2&gt;
&lt;p&gt;在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。&lt;/p&gt;
&lt;h2&gt;6. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？&lt;/h2&gt;
&lt;p&gt;可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。&lt;/p&gt;
&lt;h2&gt;7. 说一下 zookeeper 的通知机制？&lt;/h2&gt;
&lt;p&gt;客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。&lt;/p&gt;
</content><link href="/archives/java-interview-zookeeper/" rel="alternate"/><published>2020-01-17T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-rabbitmq/</id><title>Java面试题-RabbitMQ</title><updated>2020-01-16T02:08:27.809376+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1. RabbitMQ 的使用场景有哪些？&lt;/h2&gt;
&lt;p&gt;抢购活动，削峰填谷，防止系统崩塌。&lt;/p&gt;
&lt;p&gt;延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。&lt;/p&gt;
&lt;p&gt;解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。&lt;/p&gt;
&lt;h2&gt;2. RabbitMQ 有哪些重要的角色？&lt;/h2&gt;
&lt;p&gt;RabbitMQ 中重要的角色有：生产者、消费者和代理：&lt;/p&gt;
&lt;p&gt;生产者：消息的创建者，负责创建和推送数据到消息服务器；&lt;/p&gt;
&lt;p&gt;消费者：消息的接收方，用于处理数据和确认消息；&lt;/p&gt;
&lt;p&gt;代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。&lt;/p&gt;
&lt;h2&gt;3. RabbitMQ 有哪些重要的组件？&lt;/h2&gt;
&lt;p&gt;ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。&lt;/p&gt;
&lt;p&gt;Channel（信道）：消息推送使用的通道。&lt;/p&gt;
&lt;p&gt;Exchange（交换器）：用于接受、分配消息。&lt;/p&gt;
&lt;p&gt;Queue（队列）：用于存储生产者的消息。&lt;/p&gt;
&lt;p&gt;RoutingKey（路由键）：用于把生成者的数据分配到交换器上。&lt;/p&gt;
&lt;p&gt;BindingKey（绑定键）：用于把交换器的消息绑定到队列上。&lt;/p&gt;
&lt;h2&gt;4. RabbitMQ 中 vhost 的作用是什么？&lt;/h2&gt;
&lt;p&gt;vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。&lt;/p&gt;
&lt;h2&gt;5. RabbitMQ 的消息是怎么发送的？&lt;/h2&gt;
&lt;p&gt;首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。&lt;/p&gt;
&lt;h2&gt;6. RabbitMQ 怎么保证消息的稳定性？&lt;/h2&gt;
&lt;p&gt;提供了事务的功能。&lt;/p&gt;
&lt;p&gt;通过将 channel 设置为 confirm（确认）模式。&lt;/p&gt;
&lt;h2&gt;7. RabbitMQ 怎么避免消息丢失？&lt;/h2&gt;
&lt;p&gt;把消息持久化磁盘，保证服务器重启消息不丢失。&lt;/p&gt;
&lt;p&gt;每个集群中至少有一个物理磁盘，保证消息落入磁盘。&lt;/p&gt;
&lt;h2&gt;8. 要保证消息持久化成功的条件有哪些？&lt;/h2&gt;
&lt;p&gt;声明队列必须设置持久化 durable 设置为 true.&lt;/p&gt;
&lt;p&gt;消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。&lt;/p&gt;
&lt;p&gt;消息已经到达持久化交换器。&lt;/p&gt;
&lt;p&gt;消息已经到达持久化队列。&lt;/p&gt;
&lt;p&gt;以上四个条件都满足才能保证消息持久化成功。&lt;/p&gt;
&lt;h2&gt;9. RabbitMQ 持久化有什么缺点？&lt;/h2&gt;
&lt;p&gt;持久化的缺点就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。&lt;/p&gt;
&lt;h2&gt;10. RabbitMQ 有几种广播类型？&lt;/h2&gt;
&lt;p&gt;direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。&lt;/p&gt;
&lt;p&gt;headers：与 direct 类似，只是性能很差，此类型几乎用不到。&lt;/p&gt;
&lt;p&gt;fanout：分发模式，把消费分发给所有订阅者。&lt;/p&gt;
&lt;p&gt;topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。&lt;/p&gt;
&lt;h2&gt;11. RabbitMQ 怎么实现延迟消息队列？&lt;/h2&gt;
&lt;p&gt;延迟队列的实现有两种方式：&lt;/p&gt;
&lt;p&gt;通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；&lt;/p&gt;
&lt;p&gt;使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。&lt;/p&gt;
&lt;h2&gt;12. RabbitMQ 集群有什么用？&lt;/h2&gt;
&lt;p&gt;集群主要有以下两个用途：&lt;/p&gt;
&lt;p&gt;高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；&lt;/p&gt;
&lt;p&gt;高容量：集群可以承载更多的消息量。&lt;/p&gt;
&lt;h2&gt;13. RabbitMQ 节点的类型有哪些？&lt;/h2&gt;
&lt;p&gt;磁盘节点：消息会存储到磁盘。&lt;/p&gt;
&lt;p&gt;内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。&lt;/p&gt;
&lt;h2&gt;14. RabbitMQ 集群搭建需要注意哪些问题？&lt;/h2&gt;
&lt;p&gt;各节点之间使用“–link”连接，此属性不能忽略。&lt;/p&gt;
&lt;p&gt;各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。&lt;/p&gt;
&lt;p&gt;整个集群中必须包含一个磁盘节点。&lt;/p&gt;
&lt;h2&gt;15. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？&lt;/h2&gt;
&lt;p&gt;不是，原因有以下两个：&lt;/p&gt;
&lt;p&gt;存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；&lt;/p&gt;
&lt;p&gt;性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。&lt;/p&gt;
&lt;h2&gt;16. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？&lt;/h2&gt;
&lt;p&gt;如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：&lt;/p&gt;
&lt;p&gt;不能创建队列&lt;/p&gt;
&lt;p&gt;不能创建交换器&lt;/p&gt;
&lt;p&gt;不能创建绑定&lt;/p&gt;
&lt;p&gt;不能添加用户&lt;/p&gt;
&lt;p&gt;不能更改权限&lt;/p&gt;
&lt;p&gt;不能添加和删除集群节点&lt;/p&gt;
&lt;p&gt;唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。&lt;/p&gt;
&lt;h2&gt;17. RabbitMQ 对集群节点停止顺序有要求吗？&lt;/h2&gt;
&lt;p&gt;RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。&lt;/p&gt;
</content><link href="/archives/java-interview-rabbitmq/" rel="alternate"/><published>2020-01-18T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-distributedlock/</id><title>Java面试题-分布式锁</title><updated>2020-01-16T02:08:27.809338+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;为什么要使用分布式锁？为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。&lt;/p&gt;
&lt;p&gt;但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。&lt;/p&gt;
&lt;p&gt;下面介绍JAVA分布式锁的三种常用实现方式：&lt;/p&gt;
&lt;h3&gt;1.基于数据库实现分布式锁&lt;/h3&gt;
&lt;p&gt;要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录.&lt;/p&gt;
&lt;p&gt;具体操作就是在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。&lt;/p&gt;
&lt;p&gt;上面这种简单的实现有以下几个问题：&lt;/p&gt;
&lt;p&gt;1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。&lt;/p&gt;
&lt;p&gt;2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。&lt;/p&gt;
&lt;p&gt;3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。&lt;/p&gt;
&lt;p&gt;4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。&lt;/p&gt;
&lt;p&gt;当然，我们也可以有其他方式解决上面的问题。&lt;/p&gt;
&lt;p&gt;数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。&lt;/p&gt;
&lt;p&gt;没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。&lt;/p&gt;
&lt;p&gt;非阻塞的？搞一个while循环，直到insert成功再返回成功。&lt;/p&gt;
&lt;p&gt;非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。&lt;/p&gt;
&lt;p&gt;优点：借助数据库，方案简单。&lt;/p&gt;
&lt;p&gt;缺点：在实际实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑&lt;/p&gt;
&lt;h3&gt;2.基于Redis实现分布式锁&lt;/h3&gt;
&lt;p&gt;在Redis2.6.12版本之前，使用setnx命令设置key-value、使用expire命令设置key的过期时间获取分布式锁，使用del命令释放分布式锁，但是这种实现有如下一些问题：&lt;/p&gt;
&lt;p&gt;setnx命令设置完key-value后，还没来得及使用expire命令设置过期时间，当前线程挂掉了，会导致当前线程设置的key一直有效，后续线程无法正常通过setnx获取锁，造成死锁。&lt;/p&gt;
&lt;p&gt;出现这个问题是因为两个命令是分开执行并且不具备原子特性，如果能将这两个命令合二为一就可以解决问题了。在Redis2.6.12版本中实现了这个功能，Redis为set命令增加了一系列选项。&lt;/p&gt;
&lt;p&gt;也就是说现在set命令就可以实现分布式锁，下面我们来了解一下set命令（set(keyName, lockValue, “NX”, “EX”, expireSeconds)）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SET命令是原子性操作，NX指令保证只要当key不存在时才会设置value

设置的value要有唯一性，来确保锁不会被误删(value=系统时间戳+UUID)

当上述命令执行返回OK时，客户端获取锁成功，否则失败

客户端可以通过redis释放脚本来释放锁（del 命令）

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.如果锁到达了最大生存时间将会自动释放&lt;/p&gt;
&lt;p&gt;只有当前key的value和传入的value相同才会执行DEL命令。&lt;/p&gt;
&lt;p&gt;优点：高性能，借助Redis实现比较方便。&lt;/p&gt;
&lt;p&gt;缺点：线程获取锁后，如果处理时间过长会导致锁超时失效(失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。这个问题使用数据库实现分布式锁同样存在)，所以，通过超时时间来控制锁的失效时间并不是十分的靠谱。&lt;/p&gt;
&lt;h3&gt;3.基于Zookeeper实现分布式锁&lt;/h3&gt;
&lt;p&gt;ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。&lt;/p&gt;
&lt;p&gt;大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。&lt;/p&gt;
&lt;p&gt;判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。&lt;/p&gt;
&lt;p&gt;基于ZooKeeper实现分布式锁的步骤如下：&lt;/p&gt;
&lt;p&gt;创建一个目录mylock；&lt;/p&gt;
&lt;p&gt;线程A想获取锁就在mylock目录下创建临时顺序节点；&lt;/p&gt;
&lt;p&gt;获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；&lt;/p&gt;
&lt;p&gt;线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；&lt;/p&gt;
&lt;p&gt;线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。&lt;/p&gt;
&lt;p&gt;优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。具体说明如下：&lt;/p&gt;
&lt;p&gt;锁无法释放，造成死锁！使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。&lt;/p&gt;
&lt;p&gt;阻塞锁特性！使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。&lt;/p&gt;
&lt;p&gt;可重入！使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。&lt;/p&gt;
&lt;p&gt;如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。&lt;/p&gt;
&lt;p&gt;单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。&lt;/p&gt;
&lt;p&gt;缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。&lt;/p&gt;
</content><link href="/archives/java-interview-distributedlock/" rel="alternate"/><published>2020-01-19T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-linux/</id><title>Java面试题-Linux</title><updated>2020-01-16T02:08:27.809316+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1.查看内核&lt;/h2&gt;
&lt;p&gt;uname -a&lt;/p&gt;
&lt;h2&gt;2.查看系统调用列表&lt;/h2&gt;
&lt;p&gt;man 2 syscalls&lt;/p&gt;
&lt;h2&gt;3.查看系统调用说明&lt;/h2&gt;
&lt;p&gt;man 2 acct&lt;/p&gt;
&lt;h1&gt;man 2 系统调用 3 是公共库函数&lt;/h1&gt;
&lt;h2&gt;4.常用指令：&lt;/h2&gt;
&lt;p&gt;ls less more cat vi vim……（ps：vim比vi高级，可以多级撤销，语法高亮，跨平台，而且完全兼容vi）&lt;/p&gt;
&lt;h2&gt;5.远程访问&lt;/h2&gt;
&lt;p&gt;scp 文件移动到远程服务器&lt;/p&gt;
&lt;p&gt;wget 下载服务器文件到本地&lt;/p&gt;
&lt;p&gt;ssh 远程登陆&lt;/p&gt;
&lt;h2&gt;6.创建文件命令&lt;/h2&gt;
&lt;p&gt;touch 文件名&lt;/p&gt;
&lt;p&gt;vi 文件名（文件名不存在的话）&lt;/p&gt;
&lt;p&gt;mkdir 文件夹名&lt;/p&gt;
&lt;h2&gt;7. 在Linux中，怎样实现日志文件的自动循环？&lt;/h2&gt;
&lt;p&gt;‘logrotate’提供日志自动循环功能（注：将旧的日志切断，保存为.1，.2之类的文件名，并在下次切断时，逐个覆盖，并丢弃最老的）。&lt;/p&gt;
&lt;h2&gt;8. 怎样知道Linux中是谁在调度工作？&lt;/h2&gt;
&lt;p&gt;使用’at’命令加上’-l’选项，就可以查出。&lt;/p&gt;
&lt;h2&gt;9. 如何在不解压tar包的前提下，查看包里的内容？&lt;/h2&gt;
&lt;p&gt;使用’tar -tvf’。选项‘t’(显示内容)，‘v’（详细报告tar处理的文件信息），‘f’（使用档案文件或者设备）&lt;/p&gt;
&lt;h2&gt;10.查看文件内容有哪些命令可以使用？&lt;/h2&gt;
&lt;p&gt;vi 文件名 #编辑方式查看，可修改&lt;/p&gt;
&lt;p&gt;cat 文件名 #显示全部文件内容&lt;/p&gt;
&lt;p&gt;more 文件名 #分页显示文件内容&lt;/p&gt;
&lt;p&gt;less 文件名 #与 more 相似，更好的是可以往前翻页&lt;/p&gt;
&lt;p&gt;tail 文件名 #仅查看尾部，还可以指定行数&lt;/p&gt;
&lt;p&gt;head 文件名 #仅查看头部,还可以指定行数&lt;/p&gt;
&lt;h2&gt;11.通过什么命令查找执行命令?&lt;/h2&gt;
&lt;p&gt;which 只能查可执行文件&lt;/p&gt;
&lt;p&gt;whereis 只能查二进制文件、说明文档，源文件等&lt;/p&gt;
&lt;h2&gt;12. 在你的Linux机器上跟踪系统事件的守护进程名是什么？&lt;/h2&gt;
&lt;p&gt;‘syslogd’，它负责跟踪系统信息，并将跟踪日志存储在特定的日志文件里。&lt;/p&gt;
&lt;h2&gt;13. 在“/”根分区运行’fsck’命令的最低要求是什么？&lt;/h2&gt;
&lt;p&gt;“/”根分区必须挂载为只读模式才能运行fsck，读写模式则不行。&lt;/p&gt;
&lt;h2&gt;14. 如何按层次结构复制/home目录到另一个目录？&lt;/h2&gt;
&lt;p&gt;Linux的’cpio’命令可以实现效果。’cpio’可以按层次结构地复制文件和目录层次结构到另一个位置。（LCTT译注：实际上使用cpio的很少，而是使用cp -r较多）&lt;/p&gt;
&lt;h2&gt;15.怎么对命令进行取别名？&lt;/h2&gt;
&lt;p&gt;alias la='ls -a'&lt;/p&gt;
&lt;h2&gt;16.Ls 命令执行什么功能？可以带哪些参数，有什么区别？&lt;/h2&gt;
&lt;p&gt;ls 执行的功能：列出指定目录中的目录，以及文件&lt;/p&gt;
&lt;p&gt;哪些参数以及区别：a 所有文件l 详细信息，包括大小字节数，可读可写可执行的权限等&lt;/p&gt;
&lt;h2&gt;17.建立软链接(快捷方式)，以及硬链接的命令。&lt;/h2&gt;
&lt;p&gt;软链接：ln -s slink source&lt;/p&gt;
&lt;p&gt;硬链接：ln link source&lt;/p&gt;
&lt;h2&gt;18.目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？&lt;/h2&gt;
&lt;p&gt;创建目录：mkdir&lt;/p&gt;
&lt;p&gt;创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件&lt;/p&gt;
&lt;p&gt;复制文件：cp&lt;/p&gt;
&lt;h2&gt;19.怎么使一个命令在后台运行?&lt;/h2&gt;
&lt;p&gt;一般都是使用 &amp;amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)&lt;/p&gt;
&lt;h2&gt;20. 文件权限修改用什么命令？格式是怎么样的？&lt;/h2&gt;
&lt;p&gt;文件权限修改：chmod&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;p&gt;chmodu+xfile给file的属主增加执行权限chmodu+xfile给file的属主增加执行权限 chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限&lt;/p&gt;
&lt;p&gt;chmodu=rwx,g=rx,o=xfile上例的另一种形式chmodu=rwx,g=rx,o=xfile上例的另一种形式 chmod =r file 为所有用户分配读权限&lt;/p&gt;
&lt;p&gt;chmod444file同上例chmod444file同上例 chmod a-wx,a+r file同上例&lt;/p&gt;
&lt;p&gt;$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限&lt;/p&gt;
&lt;h2&gt;21.随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?&lt;/h2&gt;
&lt;p&gt;写文件命令：vi&lt;/p&gt;
&lt;p&gt;向屏幕输出带空格的字符串:echo hello world&lt;/p&gt;
&lt;h2&gt;22.终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？&lt;/h2&gt;
&lt;p&gt;终端 /dev/tty&lt;/p&gt;
&lt;p&gt;黑洞文件 /dev/null&lt;/p&gt;
&lt;h2&gt;23.移动文件用哪个命令？改名用哪个命令？复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？&lt;/h2&gt;
&lt;p&gt;mv mv&lt;/p&gt;
&lt;p&gt;cp cp -r&lt;/p&gt;
&lt;h2&gt;24.删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？&lt;/h2&gt;
&lt;p&gt;rm rm -r rmdir&lt;/p&gt;
&lt;h2&gt;25.Linux 下命令有哪几种可使用的通配符？分别代表什么含义?&lt;/h2&gt;
&lt;p&gt;“？”可替代单个字符。&lt;/p&gt;
&lt;p&gt;“*”可替代任意多个字符。&lt;/p&gt;
&lt;p&gt;方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]&lt;/p&gt;
&lt;h2&gt;26.用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)&lt;/h2&gt;
&lt;p&gt;wc 命令 – c 统计字节数 – l 统计行数 – w 统计字数。&lt;/p&gt;
&lt;h2&gt;27.Grep 命令有什么用？如何忽略大小写？如何查找不含该串的行?&lt;/h2&gt;
&lt;p&gt;是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。&lt;/p&gt;
&lt;p&gt;grep [stringSTRING] filename grep &lt;sup id="fn_ref_1"&gt;&lt;a href="#fn_1"&gt;1&lt;/a&gt;&lt;/sup&gt; filename&lt;/p&gt;
&lt;h2&gt;28.怎么使一个命令在后台运行?&lt;/h2&gt;
&lt;p&gt;一般都是使用 &amp;amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)&lt;/p&gt;
&lt;h2&gt;29.利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？&lt;/h2&gt;
&lt;p&gt;ps -ef (system v 输出)&lt;/p&gt;
&lt;p&gt;ps -aux bsd 格式输出&lt;/p&gt;
&lt;p&gt;ps -ef | grep pid&lt;/p&gt;
&lt;h2&gt;30.哪个命令专门用来查看后台任务?&lt;/h2&gt;
&lt;p&gt;job -l&lt;/p&gt;
&lt;h2&gt;31.把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?&lt;/h2&gt;
&lt;p&gt;把后台任务调到前台执行 fg&lt;/p&gt;
&lt;p&gt;把停下的后台任务在后台执行起来 bg&lt;/p&gt;
&lt;h2&gt;32.终止进程用什么命令? 带什么参数?&lt;/h2&gt;
&lt;p&gt;kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;]&lt;/p&gt;
&lt;p&gt;kill-9 pid&lt;/p&gt;
&lt;h2&gt;33.怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？&lt;/h2&gt;
&lt;p&gt;清屏：clear&lt;/p&gt;
&lt;p&gt;退出当前命令：ctrl+c 彻底退出&lt;/p&gt;
&lt;p&gt;执行睡眠 ：ctrl+z 挂起当前进程fg 恢复后台&lt;/p&gt;
&lt;p&gt;查看当前用户 id：”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名&lt;/p&gt;
&lt;p&gt;查看指定帮助：如 man adduser 这个很全 而且有例子；adduser –help 这个告诉你一些常用参数；info adduesr；&lt;/p&gt;
&lt;h2&gt;34.搜索文件用什么命令? 格式是怎么样的?&lt;/h2&gt;
&lt;p&gt;find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;&lt;/p&gt;
&lt;p&gt;whereis 加参数与文件名&lt;/p&gt;
&lt;p&gt;locate 只加文件名&lt;/p&gt;
&lt;p&gt;find 直接搜索磁盘，较慢。&lt;/p&gt;
&lt;p&gt;find / -name "string*"&lt;/p&gt;
&lt;h2&gt;35.查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?&lt;/h2&gt;
&lt;p&gt;查找自己所在的终端信息：who am i&lt;/p&gt;
&lt;p&gt;查看当前谁在使用该主机：who&lt;/p&gt;
&lt;h2&gt;36.使用什么命令查看用过的命令列表?&lt;/h2&gt;
&lt;p&gt;history&lt;/p&gt;
&lt;h2&gt;37.怎样一页一页地查看一个大文件的内容呢？&lt;/h2&gt;
&lt;p&gt;通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# cat file_name.txt | more&lt;/p&gt;
&lt;h2&gt;38.数据字典属于哪一个用户的？&lt;/h2&gt;
&lt;p&gt;数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的&lt;/p&gt;
&lt;h2&gt;39. 如何在/usr目录下找出大小超过10MB的文件？&lt;/h2&gt;
&lt;h1&gt;find /usr -size +10M&lt;/h1&gt;
&lt;h2&gt;40. 如何在/var目录下找出90天之内未被访问过的文件？&lt;/h2&gt;
&lt;h1&gt;find /var /! -atime -90&lt;/h1&gt;
&lt;h2&gt;41.如何查看Linux的默认网关？&lt;/h2&gt;
&lt;p&gt;答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。&lt;/p&gt;
&lt;h2&gt;42.使用top查看系统资源占用情况时，哪一列表示内存占用呢？&lt;/h2&gt;
&lt;p&gt;PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND&lt;/p&gt;
&lt;p&gt;301 root      20   0     0    0    0 S  0.3  0.0   0:00.08 jbd2/sda3-8&lt;/p&gt;
&lt;p&gt;1 root      20   0  2900 1428 1216 S  0.0  0.1   0:01.28 init&lt;/p&gt;
&lt;p&gt;2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd&lt;/p&gt;
&lt;p&gt;3 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0&lt;/p&gt;
&lt;p&gt;VIRT虚拟内存用量&lt;/p&gt;
&lt;p&gt;RES物理内存用量&lt;/p&gt;
&lt;p&gt;SHR共享内存用量&lt;/p&gt;
&lt;p&gt;%MEM内存用量&lt;/p&gt;
&lt;hr&gt;&lt;div class="footnotes"&gt;&lt;ol&gt;&lt;li id="fn_1"&gt;string &lt;a no-style href="#fn_ref_1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content><link href="/archives/java-interview-linux/" rel="alternate"/><published>2020-01-20T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-netty/</id><title>Java面试题-Netty</title><updated>2020-01-16T02:08:27.809293+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1.BIO、NIO和AIO的区别？&lt;/h2&gt;
&lt;p&gt;BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。&lt;/p&gt;
&lt;p&gt;伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。&lt;/p&gt;
&lt;p&gt;NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。&lt;/p&gt;
&lt;p&gt;AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，&lt;/p&gt;
&lt;p&gt;BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。&lt;/p&gt;
&lt;p&gt;NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。&lt;/p&gt;
&lt;p&gt;在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。&lt;/p&gt;
&lt;p&gt;如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。&lt;/p&gt;
&lt;h2&gt;2.NIO的组成？&lt;/h2&gt;
&lt;p&gt;Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的&lt;/p&gt;
&lt;p&gt;flip方法 ：反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式&lt;/p&gt;
&lt;p&gt;clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。&lt;/p&gt;
&lt;p&gt;rewind方法 ：重绕此缓冲区，将position置为0&lt;/p&gt;
&lt;p&gt;DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。&lt;/p&gt;
&lt;p&gt;直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。&lt;/p&gt;
&lt;p&gt;Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！&lt;/p&gt;
&lt;p&gt;Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。&lt;/p&gt;
&lt;p&gt;注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回。&lt;/p&gt;
&lt;p&gt;唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。&lt;/p&gt;
&lt;p&gt;Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。&lt;/p&gt;
&lt;p&gt;fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。&lt;/p&gt;
&lt;p&gt;Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取&lt;/p&gt;
&lt;p&gt;NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件&lt;/p&gt;
&lt;h2&gt;3.Netty的特点？&lt;/h2&gt;
&lt;p&gt;一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持&lt;/p&gt;
&lt;p&gt;使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。&lt;/p&gt;
&lt;p&gt;采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理&lt;/p&gt;
&lt;p&gt;可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持&lt;/p&gt;
&lt;p&gt;可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf&lt;/p&gt;
&lt;p&gt;通过引用计数器及时申请释放不再引用的对象，降低了GC频率&lt;/p&gt;
&lt;p&gt;使用单线程串行化的方式，高效的Reactor线程模型&lt;/p&gt;
&lt;p&gt;大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用&lt;/p&gt;
&lt;h2&gt;4.Netty的线程模型？&lt;/h2&gt;
&lt;p&gt;Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件。&lt;/p&gt;
&lt;p&gt;当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。&lt;/p&gt;
&lt;p&gt;单线程模型：&lt;/p&gt;
&lt;p&gt;所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。&lt;/p&gt;
&lt;p&gt;既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。&lt;/p&gt;
&lt;p&gt;一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。&lt;/p&gt;
&lt;p&gt;多线程模型：&lt;/p&gt;
&lt;p&gt;有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；&lt;/p&gt;
&lt;p&gt;NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。&lt;/p&gt;
&lt;p&gt;但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。&lt;/p&gt;
&lt;p&gt;主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；&lt;/p&gt;
&lt;h2&gt;5.TCP 粘包/拆包的原因及解决方法？&lt;/h2&gt;
&lt;p&gt;TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。&lt;/p&gt;
&lt;p&gt;TCP粘包/分包的原因：&lt;/p&gt;
&lt;p&gt;应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；&lt;/p&gt;
&lt;p&gt;进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&amp;gt;MSS的时候将发生拆包&lt;/p&gt;
&lt;p&gt;以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。&lt;/p&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;p&gt;消息定长：FixedLengthFrameDecoder类&lt;/p&gt;
&lt;p&gt;包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder&lt;/p&gt;
&lt;p&gt;将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。&lt;/p&gt;
&lt;h2&gt;6.了解哪几种序列化协议？&lt;/h2&gt;
&lt;p&gt;序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。&lt;/p&gt;
&lt;p&gt;影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。&lt;/p&gt;
&lt;p&gt;Java默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差&lt;/p&gt;
&lt;p&gt;XML，&lt;/p&gt;
&lt;p&gt;优点：人机可读性好，可指定元素或特性的名称。&lt;/p&gt;
&lt;p&gt;缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。&lt;/p&gt;
&lt;p&gt;JSON，是一种轻量级的数据交换格式。&lt;/p&gt;
&lt;p&gt;优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。&lt;/p&gt;
&lt;p&gt;缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。&lt;/p&gt;
&lt;p&gt;适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。&lt;/p&gt;
&lt;p&gt;Fastjson，采用一种“假定有序快速匹配”的算法。&lt;/p&gt;
&lt;p&gt;优点：接口简单易用、目前java语言中最快的json库。&lt;/p&gt;
&lt;p&gt;缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端&lt;/p&gt;
&lt;p&gt;Thrift，不仅是序列化协议，还是一个RPC框架。&lt;/p&gt;
&lt;p&gt;优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。&lt;/p&gt;
&lt;p&gt;缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案&lt;/p&gt;
&lt;p&gt;Avro，Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。&lt;/p&gt;
&lt;p&gt;优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。&lt;/p&gt;
&lt;p&gt;缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。&lt;/p&gt;
&lt;p&gt;Protobuf，将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。&lt;/p&gt;
&lt;p&gt;优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。&lt;/p&gt;
&lt;p&gt;缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化&lt;/p&gt;
&lt;p&gt;其它&lt;/p&gt;
&lt;p&gt;protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可&lt;/p&gt;
&lt;p&gt;Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口&lt;/p&gt;
&lt;p&gt;Message pack 一个高效的二进制序列化格式&lt;/p&gt;
&lt;p&gt;Hessian 采用二进制协议的轻量级remoting onhttp工具&lt;/p&gt;
&lt;p&gt;kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）&lt;/p&gt;
&lt;h2&gt;7.如何选择序列化协议？&lt;/h2&gt;
&lt;p&gt;具体场景&lt;/p&gt;
&lt;p&gt;对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。&lt;/p&gt;
&lt;p&gt;基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。&lt;/p&gt;
&lt;p&gt;对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。&lt;/p&gt;
&lt;p&gt;当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。&lt;/p&gt;
&lt;p&gt;对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。&lt;/p&gt;
&lt;p&gt;对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。&lt;/p&gt;
&lt;p&gt;如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。&lt;/p&gt;
&lt;p&gt;如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。&lt;/p&gt;
&lt;p&gt;protobuf的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、message。&lt;/p&gt;
&lt;p&gt;protobuf的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；&lt;/p&gt;
&lt;p&gt;protobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段；repeated表示的字段可以包含0个或多个数据；&lt;/p&gt;
&lt;p&gt;[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。&lt;/p&gt;
&lt;p&gt;protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。&lt;/p&gt;
&lt;p&gt;新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。&lt;/p&gt;
&lt;p&gt;编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；&lt;/p&gt;
&lt;p&gt;Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；&lt;/p&gt;
&lt;p&gt;ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类&lt;/p&gt;
&lt;p&gt;将StringBuilder转换为ByteBuf类型：copiedBuffer()方法&lt;/p&gt;
&lt;h2&gt;8.Netty的零拷贝实现？&lt;/h2&gt;
&lt;p&gt;Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。&lt;/p&gt;
&lt;p&gt;堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer&lt;/p&gt;
&lt;p&gt;CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。&lt;/p&gt;
&lt;p&gt;addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体&lt;/p&gt;
&lt;p&gt;通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。&lt;/p&gt;
&lt;p&gt;通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。&lt;/p&gt;
&lt;p&gt;Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，&lt;/p&gt;
&lt;p&gt;Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。&lt;/p&gt;
&lt;p&gt;重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。&lt;/p&gt;
&lt;h2&gt;9.Netty的高性能表现在哪些方面？&lt;/h2&gt;
&lt;p&gt;心跳，对服务端：会定时清除闲置会话inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态&lt;/p&gt;
&lt;p&gt;串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。&lt;/p&gt;
&lt;p&gt;但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。&lt;/p&gt;
&lt;p&gt;可靠性，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。&lt;/p&gt;
&lt;p&gt;Netty安全性：支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。&lt;/p&gt;
&lt;p&gt;高效并发编程的体现：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）&lt;/p&gt;
&lt;p&gt;流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。&lt;/p&gt;
&lt;p&gt;TCP参数配置：SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；&lt;/p&gt;
&lt;h2&gt;10.NIOEventLoopGroup源码？&lt;/h2&gt;
&lt;p&gt;NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。&lt;/p&gt;
&lt;p&gt;线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。&lt;/p&gt;
&lt;p&gt;如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法&lt;/p&gt;
&lt;p&gt;select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()。&lt;/p&gt;
&lt;p&gt;若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。&lt;/p&gt;
&lt;p&gt;rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。&lt;/p&gt;
&lt;p&gt;最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。&lt;/p&gt;
&lt;p&gt;接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。&lt;/p&gt;
&lt;p&gt;最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。&lt;/p&gt;
&lt;p&gt;每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。&lt;/p&gt;
&lt;p&gt;Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。&lt;/p&gt;
&lt;p&gt;Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。&lt;/p&gt;
&lt;p&gt;内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。&lt;/p&gt;
&lt;p&gt;Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。&lt;/p&gt;
&lt;p&gt;当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。&lt;/p&gt;
&lt;p&gt;大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。&lt;/p&gt;
&lt;p&gt;ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；&lt;/p&gt;
&lt;p&gt;方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。&lt;/p&gt;
&lt;p&gt;UnpooledHeapByteBuf每次都会新建一个缓冲区对象。&lt;/p&gt;
</content><link href="/archives/java-interview-netty/" rel="alternate"/><published>2020-01-21T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-dubbo/</id><title>Java面试题-Dubbo</title><updated>2020-01-16T02:08:27.809266+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1.单例设计模式&lt;/h2&gt;
&lt;p&gt;使用设计模式为了代码复用，增加可维护性。&lt;/p&gt;
&lt;p&gt;设计模式的六大原则：开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、迪米特法则（最少知道原则）、合成/聚合复用原则&lt;/p&gt;
&lt;p&gt;Singleton（创建）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。如打印机&lt;/p&gt;
&lt;p&gt;饿汉式单例模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//饿汉模式：线程安全，耗费资源。
public class HugerSingletonTest {
    //该对象的引用不可修改。还可以将对象的创建放到静态代码块中。
    private static final HugerSingletonTest ourInstance = new HugerSingletonTest();

    public static HugerSingletonTest getInstance() {
        return ourInstance;
    }
    private HugerSingletonTest() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式：非线程安全&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static Singleton ourInstance;

    public static Singleton getInstance() {
        if (null == ourInstance) {
            ourInstance = new Singleton();
        }
        return ourInstance;
    }
    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式，线程安全：给方法加锁，消耗资源。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static Singleton ourInstance;

    public synchronized static Singleton getInstance() {
        if (null == ourInstance) {
            ourInstance = new Singleton();
        }
        return ourInstance;
    }
    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式，线程安全：双重检查锁。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static Singleton ourInstance;

    public synchronized static Singleton getInstance() {
        if (null == ourInstance) {
            synchronized (Singleton.class) {
                if (null == ourInstance) {
                    ourInstance = new Singleton();
                }
            }
        }
        return ourInstance;
    }
    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析：
JVM会进行指令重排序，原本的步骤应该是先给 singleton 分配内存，然后调用 Singleton 的构造函数来初始化成员变量，形成实例，最后将singleton对象指向分配的内存空间，但有可能步骤会打乱，就会出现实例非空但没有初始化，抛出异常。将singleton声明成 volatile ，就可以解决该问题。&lt;/p&gt;
&lt;p&gt;懒汉式，线程安全：静态内部类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Singleton {
    private static class SingletonHodler {
        private static Singleton ourInstance = new Singleton();
    }

    public synchronized static Singleton getInstance() {
        return SingletonHodler.ourInstance;
    }

    private Singleton() {
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;懒汉式，线程安全：枚举&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum SingletonTest {  
    INSTANCE;  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单例模式在JDK8源码中的使用：Runtime.getRuntime()方法（饿汉式单例模式）&lt;/p&gt;
&lt;h2&gt;2.适配器设计模式&lt;/h2&gt;
&lt;p&gt;适配器模式（结构）中的角色：目标接口（Target）：客户所期待的接口、需要适配的类（Adaptee）、适配器（Adapter）。&lt;/p&gt;
&lt;p&gt;对象适配器（采用对象组合方式实现）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//适配器类实现了目标接口
public class Adapter implements Target{
    private Adaptee adaptee ;
    public Adapter() {
        super();
        this.adaptee = new Adaptee();
    }
    @Override
    public void getHeadset2() {
        adaptee.getHeadset3();
    }
    public static void main(String args[]){
        Target target = new Adapter();
        //表面上调用的是2孔插座方法，但其实调用的三孔插座方法。
        target.getHeadset2();
    }
}
interface Target{
    //两孔插座
    void getHeadset2();
}
class Adaptee{
    public void getHeadset3(){
        System.out.println("我是三孔插座！");
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;适配器模式在JDK源码的使用&lt;/p&gt;
&lt;p&gt;Arrays.asList()，其中Arrays是目标类，内部类ArrayList是适配器类，而Objects.requireNonNull(array);需要适配的类。&lt;/p&gt;
&lt;p&gt;InputStreamReader .read()，其中Reader 是目标类，InputStreamReader是适配器类，而StreamDecoder 是需要适配的类。&lt;/p&gt;
&lt;h2&gt;3.模板方法设计模式&lt;/h2&gt;
&lt;p&gt;模板方法设计模式（行为）使用了继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）&lt;/p&gt;
&lt;p&gt;模板方法设计模式在JDK源码的使用:Collections.sort()、InputStream.read()等&lt;/p&gt;
</content><link href="/archives/java-interview-dubbo/" rel="alternate"/><published>2020-01-22T12:00:00+08:06</published></entry><entry><id>/archives/java-interview-dubbo/</id><title>Java面试题-Dubbo</title><updated>2020-01-16T02:08:27.809214+00:00</updated><author><name>177</name><email>0@177.im</email><uri>https://177.im</uri></author><content>&lt;div class="notice"&gt;从网络上收集整理的Java面试题，如有侵权，请联系删除！&lt;/div&gt;&lt;h2&gt;1、测试和生产共用一套zookeeper，怎么保证消费不冲突 ？&lt;/h2&gt;
&lt;p&gt;方案1：服务发布的group设置为不同；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;dubbo:reference id="comm1" timeout="100000" interface="com.acq.facade.CommService" group="comm102" version="1.0.0" retries="0" check="false"&amp;gt;
  &amp;lt;/dubbo:reference&amp;gt;

  &amp;lt;dubbo:reference id="comm2" timeout="100000" interface="com.acq.facade.CommService" group="comm103" version="1.0.0" retries="0" check="false"&amp;gt;
  &amp;lt;/dubbo:reference&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dubbo:service interface="com.foo.BarService" version="1.0.0" &amp;gt;&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案3：dubbo白名单（Filter过滤器）&lt;/p&gt;
&lt;p&gt;1.新增一个类继承阿里巴巴的Filter&lt;/p&gt;
&lt;p&gt;2.添加阿里巴巴的约定新建配置文件 com.alibaba.dubbo.rpc.Filter，指定上面的类&lt;/p&gt;
&lt;p&gt;3.配置ip白名单&lt;/p&gt;
&lt;p&gt;4.配置服务端dubbo配置&lt;/p&gt;
&lt;h2&gt;2、dubbo运行时,突然所有的zookeeper全部宕机,dubbo是否还会继续提供服务？&lt;/h2&gt;
&lt;p&gt;会的，dubbo根据本地缓存的服务地址进行服务调用&lt;/p&gt;
&lt;p&gt;监控中心宕掉不影响使用，只是丢失部分采样数据&lt;/p&gt;
&lt;p&gt;数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务&lt;/p&gt;
&lt;p&gt;注册中心对等集群，任意一台宕掉后，将自动切换到另一台&lt;/p&gt;
&lt;p&gt;注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯&lt;/p&gt;
&lt;p&gt;服务提供者无状态，任意一台宕掉后，不影响使用&lt;/p&gt;
&lt;p&gt;服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复&lt;/p&gt;
&lt;h2&gt;3、服务提供者能实现失效踢出是什么原理？&lt;/h2&gt;
&lt;p&gt;基于zookeeper的临时节点原理&lt;/p&gt;
&lt;p&gt;持久节点&lt;/p&gt;
&lt;p&gt;所谓持久节点,是指在节点创建后,就一直存在,直到有删除操作来主动清除这个节点,也就是说不会因为创建该节点的客户端会话失效而消失&lt;/p&gt;
&lt;p&gt;临时节点&lt;/p&gt;
&lt;p&gt;临时节点的生命周期和客户端会话绑定,也就是说,如果客户端会话失效,那么这个节点就会自动被清除掉&lt;/p&gt;
&lt;h2&gt;4、创建的临时节点什么时候会被删除，是连接一断就删除吗？延时是多少？&lt;/h2&gt;
&lt;p&gt;连接断了之后，ZK不会马上移除临时数据，只有当SESSIONEXPIRED之后，才会把这个会话建立的临时数据移除。因此，用户需要谨慎设置Session_TimeOut&lt;/p&gt;
&lt;h2&gt;5、Dubbo在安全机制方面是如何解决的 ？&lt;/h2&gt;
&lt;p&gt;Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。&lt;/p&gt;
&lt;h2&gt;6、说说核心的配置有哪些？&lt;/h2&gt;
&lt;p&gt;dubbo:service/ 服务提供者暴露服务配置&lt;/p&gt;
&lt;p&gt;dubbo:reference/ 服务消费者引用服务配置&lt;/p&gt;
&lt;p&gt;dubbo:protocol/ 服务提供者协议配置&lt;/p&gt;
&lt;p&gt;dubbo:registry/ 注册中心配置&lt;/p&gt;
&lt;p&gt;dubbo:application/ 应用信息配置&lt;/p&gt;
&lt;p&gt;dubbo:provider/ 服务提供者缺省值配置&lt;/p&gt;
&lt;p&gt;dubbo:consumer/ 服务消费者缺省值配置&lt;/p&gt;
&lt;p&gt;dubbo:method/ 方法级配置&lt;/p&gt;
</content><link href="/archives/java-interview-dubbo/" rel="alternate"/><published>2020-01-23T12:00:00+08:06</published></entry></feed>